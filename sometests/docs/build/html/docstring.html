

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Docstring &mdash; geo_bezier_3d v.0.2 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Examples" href="examples.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> geo_bezier_3d
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Conteúdos:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="howto.html">How To</a></li>
<li class="toctree-l1"><a class="reference internal" href="bezier.html">Abordagem de Bézier</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Docstring</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">geo_bezier_3d</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Docstring</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/docstring.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="docstring">
<span id="id1"></span><h1>Docstring<a class="headerlink" href="#docstring" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-creating_solid"></span><p>O usuário recebe nessa página todas informações dos argumentos de todas as funções presentes no código.</p>
<dl class="function">
<dt id="creating_solid.berstein">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">berstein</code><span class="sig-paren">(</span><em class="sig-param">n_p</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.berstein" title="Permalink to this definition">¶</a></dt>
<dd><p>Matemática chave por trás das curvas/superfícies de Bézier, dentro da própria função <code class="docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Não há necessidade alguma de manipulação por parte do usuário.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.bounds_into_single_solid">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">bounds_into_single_solid</code><span class="sig-paren">(</span><em class="sig-param">identif_list</em>, <em class="sig-param">identif</em>, <em class="sig-param">solid_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.bounds_into_single_solid" title="Permalink to this definition">¶</a></dt>
<dd><p>Função que agrega diversas features em apenas um sólido. Se faz necessário na hora de realizar um mirror atrelado a um <code class="docutils literal notranslate"><span class="pre">'target'</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif_list</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,strs</span></code>) – Lista dos identificadores das features que farão parte do sólido: <code class="docutils literal notranslate"><span class="pre">['0','3','2']</span></code>, por exemplo.</p></li>
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span>.</p></li>
<li><p><strong>solid_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.create_point_matrix">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">create_point_matrix</code><span class="sig-paren">(</span><em class="sig-param">deflection=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.create_point_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxílio na hora de setar os pontos necessários para as equações da função <a class="reference internal" href="#creating_solid.gen_bezier_surface" title="creating_solid.gen_bezier_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deflection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> caso queira que a superfície passe necessariamente pelos pontos de controle
(pontos intermediários, os que normalmente dão a curvatura suave à superfície). Baseia-se num artifício
matemático que <em>hackeia</em> a Bézier, forçando-a a fazer algo que normalmente não faria.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">deflection=True</span></code> <strong>não demonstrará efeito em todos os casos!</strong></p>
<p>O parâmetro pode ficar setado como True sem danificar o código, porém só efetivamente desviará a superfície
caso <code class="docutils literal notranslate"><span class="pre">num_u_points</span> <span class="pre">=</span> <span class="pre">3</span></code> ao mesmo tempo que <code class="docutils literal notranslate"><span class="pre">num_v_points</span> <span class="pre">=</span> <span class="pre">2</span></code> ou vice-versa.</p>
<p><strong>O porquê da restrição:</strong></p>
<p>Como pode-se imaginar, não há necessidade de desviar a superfície para passar em pontos intermediários caso existam apenas 2
pontos nas direççoes <span class="math notranslate nohighlight">\({u}\)</span> e <span class="math notranslate nohighlight">\({v}\)</span> pois não há pontos intermediários. Também, caso a superfície tenha 3 pontos em cada direção
<span class="math notranslate nohighlight">\({u}\)</span> e <span class="math notranslate nohighlight">\({v}\)</span> ou mais, torna-se <em>matematicamente complicado</em> descrever o desvio.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="creating_solid.epsi_plot">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">epsi_plot</code><span class="sig-paren">(</span><em class="sig-param">direction</em>, <em class="sig-param">grid=True</em>, <em class="sig-param">ticks='full'</em>, <em class="sig-param">integral=False</em>, <em class="sig-param">raf='normal'</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.epsi_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Confira se os limites estão corretos, camada por camada ou por amostragem, em qualquer direção.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Poderá assumir os seguintes valores: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'z'</span></code>.</p></li>
<li><p><strong>grid</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso houver número demasiado de nós (&gt;250), setar como <code class="docutils literal notranslate"><span class="pre">False</span></code> auxiliará na visualização.</p></li>
<li><p><strong>ticks</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Definição dos ticks da imagem (números que acompanham os eixos). Pode assumir <code class="docutils literal notranslate"><span class="pre">full</span></code> (ideal para poucos nós), <code class="docutils literal notranslate"><span class="pre">some</span></code> (ideal para número alto de nós), <code class="docutils literal notranslate"><span class="pre">none</span></code> (imagem limpa).</p></li>
<li><p><strong>integral</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Se o usuário quiser conferir meticulosamente todas as camadas, sete como <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>raf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Se o usuário quiser conferir alguma <span class="math notranslate nohighlight">\({\epsilon}\)</span> refinada, setar com <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'z'</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_bezier_surface">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_bezier_surface</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">show_equation=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_bezier_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>As equações de Bézier são governadas pelos parâmetros <span class="math notranslate nohighlight">\({u}\)</span> e <span class="math notranslate nohighlight">\({v}\)</span> e fornecem leis para curvas/superfícies.</p>
<p>São definidas por pontos arbitrados pelo usuário, tendo um mínimo de 2 em cada direção <span class="math notranslate nohighlight">\({u}\)</span> e <span class="math notranslate nohighlight">\({v}\)</span> e sem algum máximo pré-determinado.</p>
<p>Os pontos iniciais e finais determinam onde a curva começa e termina. <em>São os únicos pontos por onde a Bézier (naturalmente) passará com certeza</em>.
Os pontos intermediários estão encarregados de fornecer à Bézier uma curvatura suave, sem canto vivo/descontinuidade,
portanto a curva/superfície nunca <em>encosta</em> neles (para burlar essa situação, veja a função <a class="reference internal" href="#creating_solid.create_point_matrix" title="creating_solid.create_point_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_point_matrix()</span></code></a>).</p>
<p>O grau das equações é definido por número de pontos definidos pelo usuário - 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um name para a superfície. Não há regras.</p></li>
<li><p><strong>show_equations</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> caso queira visualizar as equações governantes da superfície em questão.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">identif()</span></code> <strong>necessita atenção especial</strong>: o usuário voltará a chamar o parâmetro por diversas vezes ao decorrer do código.</p>
</div>
<p>É importante frisar que, caso construída uma superfície muito complexa (com variações não lineares entre os pontos em mais de 2 direções <span class="math notranslate nohighlight">\({xyz}\)</span>, uma
superfície muito torcida), a convergência das equações não é garantida.</p>
<a class="reference internal image-reference" href="_images/ex_supcomplexa.png"><img alt="_images/ex_supcomplexa.png" class="align-right" src="_images/ex_supcomplexa.png" style="width: 279.2px; height: 266.40000000000003px;" /></a>
<p>A superfície ao lado possui seguintes equações:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(𝑢,𝑣) = 4𝑢²−2𝑢+𝑣²(3𝑢2−6𝑢+3)+𝑣(−6𝑢²+12𝑢−6)+3

y(𝑢,𝑣) = 2𝑢²+𝑣²(2𝑢²+1)+𝑣(4−4𝑢²)

z(𝑢,𝑣) = −3𝑢²+4𝑢+𝑣²(−11𝑢²+14𝑢−7)+𝑣(18𝑢²−20𝑢+10)
</pre></div>
</div>
<p>Evidentemente, são equações longas, não lineares e dependentes de mais de uma variável. O solver não se dá muito bem com isso. O usuário pode tentar a sorte, simplificar a superfície ou tentar outro tipo de solver na hora de gerar a matriz <span class="math notranslate nohighlight">\({\epsilon}\)</span> na função <code class="docutils literal notranslate"><span class="pre">gen_epsi_bezier_surface()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_cylinder">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_cylinder</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">bases_plane</em>, <em class="sig-param">radius</em>, <em class="sig-param">center_1</em>, <em class="sig-param">center_2</em>, <em class="sig-param">init_height</em>, <em class="sig-param">final_height</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Crie um cilíndro ao longo de <span class="math notranslate nohighlight">\({x}\)</span>, <span class="math notranslate nohighlight">\({y}\)</span> ou <span class="math notranslate nohighlight">\({z}\)</span> em qualquer ponto do domínio. Não há possibilidade de rotações.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um nome para a feature. Não há regras.</p></li>
<li><p><strong>bases_plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – O plano transversal ao cilindro: onde a base ou o topo ficam (são paralelos). Deverá assumir <code class="docutils literal notranslate"><span class="pre">'xy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xz'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'zy'</span></code>.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Raio da base/topo.</p></li>
<li><p><strong>center1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – 1ª coordenada do centro da base/topo. O eixo correspondende à coordenada dependerá de qual <code class="docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>center2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – 2ª coordenada do centro da base/topo. O eixo correspondende à coordenada dependerá de qual <code class="docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Início do cilindro. Deve ser menor do que <code class="docutils literal notranslate"><span class="pre">final_height</span></code>.</p></li>
<li><p><strong>final_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Final do cilindro. Deve ser maior do que <code class="docutils literal notranslate"><span class="pre">init_height</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_bezier_surface">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_bezier_surface</code><span class="sig-paren">(</span><em class="sig-param">surface_type</em>, <em class="sig-param">plane</em>, <em class="sig-param">identif</em>, <em class="sig-param">solver='scipy'</em>, <em class="sig-param">add_or_sub='sub'</em>, <em class="sig-param">interval=numpy.arange</em>, <em class="sig-param">bez_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_bezier_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Nesta função, usa-se as equações geradas pelos pontos fornecidos pelo usuário para setar os limites de onde é sólido (na <span class="math notranslate nohighlight">\({\epsilon}\)</span>, <code class="docutils literal notranslate"><span class="pre">1</span></code>) e onde
não é sólido (na <span class="math notranslate nohighlight">\({\epsilon}\)</span>, <code class="docutils literal notranslate"><span class="pre">0</span></code>). Também se seta o que é considerado entrada e saída, ou ambos.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – <p>Defina se a superfície em questão é considerada uma entrada, uma saída ou ambos em relação ao domínio.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>tipo de limite da superfície</p></th>
<th class="head"><p>Setar <code class="docutils literal notranslate"><span class="pre">surface_type</span></code> como</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>entrada</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">entry'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>saída</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">exit'</span></code></p></td>
</tr>
<tr class="row-even"><td><p>entrada e saída simult.</p></td>
<td><p>ambos, tanto faz</p></td>
</tr>
<tr class="row-odd"><td><p>entrada e saída simult. + entrada</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">entry'</span></code></p></td>
</tr>
<tr class="row-even"><td><p>entrada e saída simult. + saída</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">exit'</span></code></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Escolha o melhor plane para resolver sua superfície. Pode assumir apenas <code class="docutils literal notranslate"><span class="pre">'xz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xy'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'zy'</span></code>. Uma superfície sem espessura em relação a um plano não pode ser resolvida por esse plano.</p></li>
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="docutils literal notranslate"><span class="pre">identif</span></code> da superfície em questão.</p></li>
<li><p><strong>solver</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Deve assumir <code class="docutils literal notranslate"><span class="pre">'scipy'</span></code> or <code class="docutils literal notranslate"><span class="pre">'sympy'</span></code>. Normalmente <code class="docutils literal notranslate"><span class="pre">'scipy'</span></code> é mais eficiente e barato.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina o mecanismo de criação da <span class="math notranslate nohighlight">\({\epsilon}\)</span>. Caso assuma <code class="docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informação da superfície para a <span class="math notranslate nohighlight">\({\epsilon}\)</span> será através de adição (ou subtração, caso seja uma <code class="docutils literal notranslate"><span class="pre">entry/exit</span> <span class="pre">and/or</span> <span class="pre">exit</span></code>), caso ideal para obtenção de intersecções (não esquecer de usar a função <code class="docutils literal notranslate"><span class="pre">normalize_epsi()</span></code> para correção). Caso assuma <code class="docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo será através de substituição (metodologia padrão).</p></li>
<li><p><strong>interval</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,</span> <span class="pre">np.arange</span></code>, optional) – Intervalo no qual o solver <code class="docutils literal notranslate"><span class="pre">'scipy'</span></code> vai buscar as raízes. O padrão é o que apresenta melhores resultados.</p></li>
<li><p><strong>bez_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt><strong>Exemplo:</strong></dt><dd><div class="figure align-center">
<a class="reference internal image-reference" href="_images/ex_entradasaidasaida.png"><img alt="_images/ex_entradasaidasaida.png" src="_images/ex_entradasaidasaida.png" style="width: 491.4px; height: 489.99999999999994px;" /></a>
</div>
<p>Podemos notar 2 supefícies na figura, uma verde, <code class="docutils literal notranslate"><span class="pre">identif='0'</span></code>, e outra roxa <code class="docutils literal notranslate"><span class="pre">identif='1'</span></code>.
De acordo com esta situação, a invocação da função <code class="docutils literal notranslate"><span class="pre">gen_epsi()</span></code> pode se dar na seguinte forma:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen_epsi</span><span class="p">(</span><span class="s1">&#39;entry+exit and/or entry&#39;</span><span class="p">,</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">gen_epsi</span><span class="p">(</span><span class="s1">&#39;entry+exit and/or exit&#39;</span><span class="p">,</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Podemos notar também um ponto que é o início de um vetor perpendicular ao plane <span class="math notranslate nohighlight">\({zy}\)</span>. Este vetor é a representação do que define o <code class="docutils literal notranslate"><span class="pre">surface_type</span></code> de cada superfície.
Toda vez que o vetor encontrar alguma superfícies, será definido um limite para a criação da <span class="math notranslate nohighlight">\({\epsilon}\)</span>.
Devemos imaginar que para cada combinação de coordenada <span class="math notranslate nohighlight">\({z}\)</span> e <span class="math notranslate nohighlight">\({y}\)</span> (espaçamento definido por <span class="math notranslate nohighlight">\({dz}\)</span> e <span class="math notranslate nohighlight">\({dy}\)</span>) um vetor desses é originado. Portanto:</p>
<blockquote>
<div><p>1. O sólido verde é considerado somente entrada pois, no instante em que é interceptado pelos vetores,
<strong>entra-se no sólido</strong>.</p>
<p>2. O sólido roxo deve ser dividido em 2 partes e é considerado entrada e sáida + saída. A primeira parte é a superior, logo acima da superfície verde.
Toda esta parte será interceptada pelos vetores duas vezes e <strong>por isso é considerada entrada e saída</strong>. A segunda parte é a inferior, que ‘compartilha’
altura com a superfície verde. Esta parte será interceptada pelos vetores apenas uma vez e em todas elas o sólido já terá acabado, por isso é considerada
como <strong>saída</strong>.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Caso construída uma superfície que possua segmentos com possíveis entradas e saídas simultâneas (superfície roxa), certificar que a superfície seja construída
no sentido positivo: os pontos iniciais devem ser mais próximos da origem do que os pontos finais, independente do plane.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_cylinder">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_cylinder</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">surface_type</em>, <em class="sig-param">add_or_sub='sub'</em>, <em class="sig-param">cyl_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração da <span class="math notranslate nohighlight">\({\epsilon}\)</span> da esfera criada anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="docutils literal notranslate"><span class="pre">identif</span></code> do cilindro em questão.</p></li>
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina se o cilindro será um objeto (adição de “material”) ou um contorno (subtração de “material”) . Deve assumir <code class="docutils literal notranslate"><span class="pre">'solid'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'contour'</span></code>.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina o mecanismo de criação da <span class="math notranslate nohighlight">\({\epsilon}\)</span>. Caso assuma <code class="docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informação da superfície para a <span class="math notranslate nohighlight">\({\epsilon}\)</span> será através de adição (ou subtração, caso seja um <code class="docutils literal notranslate"><span class="pre">contour</span></code>), caso ideal para obtenção de intersecções (não esquecer de usar a função <code class="docutils literal notranslate"><span class="pre">normalize_epsi()</span></code> para correção). Caso assuma <code class="docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo será através de substituição (metodologia padrão).</p></li>
<li><p><strong>cyl_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_extrude">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_extrude</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">ext_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_extrude" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração da <span class="math notranslate nohighlight">\({\epsilon}\)</span> do Extrude criado anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="docutils literal notranslate"><span class="pre">identif</span></code> do extrude em questão.</p></li>
<li><p><strong>ext_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_mirror">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_mirror</code><span class="sig-paren">(</span><em class="sig-param">target</em>, <em class="sig-param">direction</em>, <em class="sig-param">mirror_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Espelhe o domínio inteiro ou apenas um sólido construído com <code class="docutils literal notranslate"><span class="pre">bounds_into_single_solid()</span></code>.</p>
<p>Após a criação de um espelhamento, normalizar a matriz <span class="math notranslate nohighlight">\({\epsilon}\)</span> com a função <code class="docutils literal notranslate"><span class="pre">normalize_epsi</span></code>. Maiores informações em <a class="reference internal" href="howto.html#howto"><span class="std std-ref">How To</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Pode assumir <code class="docutils literal notranslate"><span class="pre">'whole_domain'</span></code> (caso o mirror seja feito ao longo de todo domínio) ou a identificação do sólido criado com <code class="docutils literal notranslate"><span class="pre">bounds_into_single_solid()</span></code> (caso mirror seja feito em apenas uma parte do domínio).</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Direção na qual o mirror será efetuado. Deve assumir <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'z'</span></code>.</p></li>
<li><p><strong>mirror_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_quad_prism">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_quad_prism</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">surface_type</em>, <em class="sig-param">add_or_sub='sub'</em>, <em class="sig-param">qp_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_quad_prism" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração da <span class="math notranslate nohighlight">\({\epsilon}\)</span> do prisma criado anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="docutils literal notranslate"><span class="pre">identif</span></code> do cubóide em questão.</p></li>
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina se o cubóide será um objeto (adição de “material”) ou um contorno (subtração de “material”) . Deve assumir <code class="docutils literal notranslate"><span class="pre">'solid'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'contour'</span></code>.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina o mecanismo de criação da <span class="math notranslate nohighlight">\({\epsilon}\)</span>. Caso assuma <code class="docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informação da superfície para a <span class="math notranslate nohighlight">\({\epsilon}\)</span> será através de adição (ou subtração, caso seja um <code class="docutils literal notranslate"><span class="pre">contour</span></code>), caso ideal para obtenção de intersecções (não esquecer de usar a função <code class="docutils literal notranslate"><span class="pre">normalize_epsi()</span></code> para correção). Caso assuma <code class="docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo será através de substituição (metodologia padrão).</p></li>
<li><p><strong>qp_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_revolve">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_revolve</code><span class="sig-paren">(</span><em class="sig-param">identif</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_revolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração da <span class="math notranslate nohighlight">\({\epsilon}\)</span> do Revolve criado anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="docutils literal notranslate"><span class="pre">identif</span></code> do revolve em questão.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_epsi_sphere">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_sphere</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">surface_type</em>, <em class="sig-param">add_or_sub='sub'</em>, <em class="sig-param">sph_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração da <span class="math notranslate nohighlight">\({\epsilon}\)</span> da esfera criada anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="docutils literal notranslate"><span class="pre">identif</span></code> da esfera em questão.</p></li>
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina se a esfera será um objeto (adição de “material”) ou um contorno (subtração de “material”) . Deve assumir <code class="docutils literal notranslate"><span class="pre">'solid'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'contour'</span></code>.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina o mecanismo de criação da <span class="math notranslate nohighlight">\({\epsilon}\)</span>. Caso assuma <code class="docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informação da superfície para a <span class="math notranslate nohighlight">\({\epsilon}\)</span> será através de adição (ou subtração, caso seja um <code class="docutils literal notranslate"><span class="pre">contour</span></code>), caso ideal para obtenção de intersecções (não esquecer de usar a função <code class="docutils literal notranslate"><span class="pre">normalize_epsi()</span></code> para correção). Caso assuma <code class="docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo será através de substituição (metodologia padrão).</p></li>
<li><p><strong>sph_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_extrude_profile">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_extrude_profile</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">direction</em>, <em class="sig-param">init_height</em>, <em class="sig-param">final_height</em>, <em class="sig-param">deflection=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_extrude_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Criação de um perfil que será posteriormente extrudado. O input da função deve assumir a seguinte forma de um dicionário:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#forma geral</span>

<span class="n">c</span><span class="o">.</span><span class="n">extrude_information</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;#0 identif&#39;</span><span class="p">:[</span><span class="s1">&#39;line type&#39;</span><span class="p">,</span><span class="s1">&#39;direção da solução&#39;</span><span class="p">,[</span><span class="n">pontos</span> <span class="n">de</span> <span class="n">controle</span><span class="p">]],</span>
                       <span class="s1">&#39;#1 identif&#39;</span><span class="p">:[</span><span class="s1">&#39;line type&#39;</span><span class="p">,</span><span class="s1">&#39;direção da solução&#39;</span><span class="p">,[</span><span class="n">pontos</span> <span class="n">de</span> <span class="n">controle</span><span class="p">]]}</span>

<span class="c1">#forma aplicada</span>

<span class="n">c</span><span class="o">.</span><span class="n">extrude_information</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="s1">&#39;entry+exit and/or exit&#39;</span> <span class="p">,</span><span class="s1">&#39;v&#39;</span><span class="p">,[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]]],</span>
                       <span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="s1">&#39;entry+exit and/or entry&#39;</span><span class="p">,</span><span class="s1">&#39;v&#39;</span><span class="p">,[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]]]}</span>
</pre></div>
</div>
<p>A key do dicionário, <code class="docutils literal notranslate"><span class="pre">'#0</span> <span class="pre">identif'</span></code>, é o identificador da curva criada. Também também carrega a função de determinar a ordem em que as curvas serãor resolvidas (<em>normalmente</em>
o usuário vai querer resolver primeiro todas as entradas);</p>
<p>O primeiro termo da lista do dicionário, <code class="docutils literal notranslate"><span class="pre">'line</span> <span class="pre">type'</span></code>, determina que tipo de limite a curva em questão é - entrada ou saída. Deve assumir <code class="docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">exit'</span></code> ou
<code class="docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">entry'</span></code>;</p>
<p>O segundo termo da lista do dicionário - <code class="docutils literal notranslate"><span class="pre">'direção</span> <span class="pre">da</span> <span class="pre">solução'</span></code> - pode assumir <code class="docutils literal notranslate"><span class="pre">'v'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'h'</span></code>, que significam vertical e horizontal, respectivamente. Caso seja escolhido vertical,
para cada nó no eixo vertical será disparado um vetor que interceptará as curvas. Caso essa curva seja entrada, a partir dessa intersecção o algorítmo interpretará como dentro do
perfil de extrude. Caso essa curva seja saída, o algorítmo interpretará como fora do perfil de extrude.</p>
<p>O terceiro e último termo do dicionário é uma lista, <code class="docutils literal notranslate"><span class="pre">[pontos</span> <span class="pre">de</span> <span class="pre">controle]</span></code>, contendo todos os pontos de controle de cada curva de Bézier que setará o perfil de extrude.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Nessa função, as curvas de Bézier podem ser solucionadas na direção do eixo horizontal (da esquerda para a direita) ou pelo eixo vertical (de baixo para cima). Essa configuração é definida pelo termo <code class="docutils literal notranslate"><span class="pre">'direção</span> <span class="pre">da</span> <span class="pre">solução'</span></code>, que pode assumir <code class="docutils literal notranslate"><span class="pre">'h'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'v'</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um name para a feature. Não há regras.</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Direção na qual o extrude ocorrerá. Deve assumir <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'z'</span></code>.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Início do extrude, relacionado à <code class="docutils literal notranslate"><span class="pre">direction</span></code></p></li>
<li><p><strong>final_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Final do extrude, relacionado à <code class="docutils literal notranslate"><span class="pre">direction</span></code></p></li>
<li><p><strong>deflection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> caso queira que a curva passe pelo ponto de controle intermediário (o que normalmente dá curvatura suave à curva). Baseia-se num artifício matemático que <em>hackeia</em> a Bézier, forçando-a a fazer algo que normalmente não faria. <strong>Funcional apenas para curvas com 3 pontos</strong>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_output">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_output</code><span class="sig-paren">(</span><em class="sig-param">names</em>, <em class="sig-param">out_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração dos arquivos de saída. Tornam possível a visualização no ParaView da <span class="math notranslate nohighlight">\({\epsilon}\)</span>, bem como a resolução das equações
de Navier Stokes nas redondezas do sólido criado.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Entre com o name que será dado aos arquivos gerado pelo programa.</p></li>
<li><p><strong>out_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_quad_prism">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_quad_prism</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">a</em>, <em class="sig-param">b</em>, <em class="sig-param">c</em>, <em class="sig-param">reference_point</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_quad_prism" title="Permalink to this definition">¶</a></dt>
<dd><p>Crie um cubóide (prisma quadrangular) em qualquer posição do domínio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>a</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Aresta na direção de <span class="math notranslate nohighlight">\({x}\)</span>.</p></li>
<li><p><strong>b</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Aresta na direção de <span class="math notranslate nohighlight">\({y}\)</span>.</p></li>
<li><p><strong>c</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Aresta na direção de <span class="math notranslate nohighlight">\({z}\)</span>.</p></li>
<li><p><strong>reference_point</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,</span> <span class="pre">float</span></code>) – Coordenadas do ponto de referência para posicionamento do cubóide. É o vértice mais próximo da origem do plano cartesiano.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_raf_information">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_raf_information</code><span class="sig-paren">(</span><em class="sig-param">nraf</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_raf_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração de informações para <span class="math notranslate nohighlight">\({\epsilon}\)</span> refinada, importante arquivo para o <code class="xref py py-obj docutils literal notranslate"><span class="pre">Incompact3d</span></code>. O objetivo é obter maior precisão em cada dimensão por vez.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nraf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Entre com o número de vezes que gostaria de multiplicar os nós (refinar a malha).</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_revolve_profile">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_revolve_profile</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">direction</em>, <em class="sig-param">center_1</em>, <em class="sig-param">center_2</em>, <em class="sig-param">init_height</em>, <em class="sig-param">deflection=False</em>, <em class="sig-param">rev_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_revolve_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construa um perfil de revolve por meio de curvas de Bézier sempre no sentido positivo, sem idas e voltas (cada coordenada <span class="math notranslate nohighlight">\({axis}\)</span> so pode ter 1 <span class="math notranslate nohighlight">\({radius}\)</span> correspondente).</p>
<p><strong>Primeiro ponto de ambos limites (superior e inferior) sempre deve ser 0. Perfil superior e perfil inferior devem terminar no mesmo ponto.</strong></p>
<p>Para confirmar a efetividade da função, checar que dentro da área do perfil de revolve (área limitada pelo perfil superior e inferior), para toda linha vermelha pontilhada deve existir uma linha cinza contínua.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Nessa função, diferentemente da função <code class="docutils literal notranslate"><span class="pre">gen_extrude_profile()</span></code>, as curvas de Bézier serãos sempre solucionadas na direção do eixo vertical, de baixo para cima.</p>
</div>
<p>As informações de entrada para as curvas devem ser feitas da seguinte forma (em dicionário):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#forma geral</span>

<span class="n">c</span><span class="o">.</span><span class="n">inferior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;n=0&#39;</span><span class="p">:</span>  <span class="p">[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                         <span class="s1">&#39;n+1&#39;</span><span class="p">:[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                        <span class="p">}</span>

<span class="n">c</span><span class="o">.</span><span class="n">superior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;n=0&#39;</span><span class="p">:</span>  <span class="p">[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                         <span class="s1">&#39;n+1&#39;</span><span class="p">:[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                        <span class="p">}</span>

<span class="c1">#forma aplicada</span>

<span class="n">c</span><span class="o">.</span><span class="n">inferior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;0&#39;</span><span class="p">:[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]],</span>
                         <span class="s1">&#39;1&#39;</span><span class="p">:[[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]]],</span>
                         <span class="s1">&#39;2&#39;</span><span class="p">:[[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]]</span>
                        <span class="p">}</span>

<span class="n">c</span><span class="o">.</span><span class="n">superior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;0&#39;</span><span class="p">:[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]],</span>
                         <span class="s1">&#39;1&#39;</span><span class="p">:[[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]],</span>
                         <span class="s1">&#39;2&#39;</span><span class="p">:[[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]]],</span>
                         <span class="s1">&#39;3&#39;</span><span class="p">:[[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]]]</span>
                        <span class="p">}</span>
</pre></div>
</div>
<p>A key do dicionário, <code class="docutils literal notranslate"><span class="pre">n</span></code>, deve começar em 0 e aumentar 1 toda vez que uma nova curva for adicionada;</p>
<p>O único termo do dicionário deve ser uma lista de <span class="math notranslate nohighlight">\({p}\)</span> pontos bidimensionais, onde <span class="math notranslate nohighlight">\({p}\)</span> pode assumir valores diferentes para cada curva (mínimo 2 e máximo (recomendado) 5);</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um nome para a feature. Não há regras.</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Direção longitudinal do revolve. Deve assumir <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'z'</span></code>.</p></li>
<li><p><strong>center_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – 1ª coordenada do centro da base/topo. O eixo correspondende à coordenada dependerá de qual <code class="docutils literal notranslate"><span class="pre">direction</span></code> foi definido.</p></li>
<li><p><strong>center_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – 2ª coordenada do centro da base/topo. O eixo correspondende à coordenada dependerá de qual <code class="docutils literal notranslate"><span class="pre">direction</span></code> foi definido.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Início do revolve na direção longitudinal.</p></li>
<li><p><strong>deflection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> caso queira que a curva passe pelo ponto de controle intermediário (o que normalmente dá curvatura suave à curva). Baseia-se num artifício matemático que <em>hackeia</em> a Bézier, forçando-a a fazer algo que normalmente não faria. <strong>Funcional apenas para curvas com 3 pontos</strong>.</p></li>
<li><p><strong>rev_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_sphere">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_sphere</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">radius</em>, <em class="sig-param">cex</em>, <em class="sig-param">cey</em>, <em class="sig-param">cez</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Crie uma esfera em qualquer posição do domínio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um nome para a feature. Não há regras.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Raio da esfera.</p></li>
<li><p><strong>cex</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coordenada <span class="math notranslate nohighlight">\({x}\)</span> do centro.</p></li>
<li><p><strong>cey</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coordenada <span class="math notranslate nohighlight">\({y}\)</span> do centro.</p></li>
<li><p><strong>cez</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coordenada <span class="math notranslate nohighlight">\({z}\)</span> do centro.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.gen_toroid">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_toroid</code><span class="sig-paren">(</span><em class="sig-param">identif</em>, <em class="sig-param">name</em>, <em class="sig-param">bases_plane</em>, <em class="sig-param">external_radius</em>, <em class="sig-param">profile_circle_radius</em>, <em class="sig-param">center_1</em>, <em class="sig-param">center_2</em>, <em class="sig-param">init_height</em>, <em class="sig-param">tor_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_toroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Função facilitadora para criação de um toróide por meio da função <code class="docutils literal notranslate"><span class="pre">gen_revolve_profile()</span></code>. Não necessita de informações (dicionário) de entrada.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <strong>identificação</strong> da feature com <span class="math notranslate nohighlight">\({n}\)</span>, onde <span class="math notranslate nohighlight">\({n=0,1,2,3...}\)</span> (começar em <code class="docutils literal notranslate"><span class="pre">'0'</span></code> e somar <code class="docutils literal notranslate"><span class="pre">'1'</span></code> a cada nova superfície).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um nome para a feature. Não há regras.</p></li>
<li><p><strong>bases_plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – O plano transversal ao toróide, plano no qual o círculo central é paralelo. Deverá assumir <code class="docutils literal notranslate"><span class="pre">'xy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xz'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'zy'</span></code>.</p></li>
<li><p><strong>external_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Raio total do toróide, o ponto mais externo.</p></li>
<li><p><strong>profile_circle_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Raio do perfil circular transversal do toróide.</p></li>
<li><p><strong>center_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – 1ª coordenada do centro da base/topo. O eixo correspondende à coordenada dependerá de qual <code class="docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>center_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – 2ª coordenada do centro da base/topo. O eixo correspondende à coordenada dependerá de qual <code class="docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Início do toróide na direção perpendicular ao <code class="docutils literal notranslate"><span class="pre">bases_plane</span></code> definido.</p></li>
<li><p><strong>tor_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.normalize_epsi">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">normalize_epsi</code><span class="sig-paren">(</span><em class="sig-param">intersection=False</em>, <em class="sig-param">target=2</em>, <em class="sig-param">epsi_raf_path=False</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.normalize_epsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Ideal chamar essa função antes de gerar os arquivos de saída. Corrige qualquer valor inadequado da <span class="math notranslate nohighlight">\({\epsilon}\)</span> (menor do que 0 ou maior do que 1) que podem ser gerados ao decorrer do projeto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intersection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Setar como <code class="docutils literal notranslate"><span class="pre">True</span></code> para validar intersecções entre superfícies. Maiores informações em <a class="reference internal" href="howto.html#intersec"><span class="std std-ref">2.8 Normalização/Intersecções</span></a>.</p></li>
<li><p><strong>target</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso <code class="docutils literal notranslate"><span class="pre">intersection=True</span></code>, setar nesse argumento qual valor será considerado o alvo para transformar as intersecções em sólidos independentes. Caso assuma <code class="docutils literal notranslate"><span class="pre">2</span></code>, por exemplo, todos os valores na <span class="math notranslate nohighlight">\({\epsilon}\)</span> que forem menor do que 2 serão setados como 0, enquanto todos valores iguais ou superiores a 2 serão setados como 1.</p></li>
<li><p><strong>epsi_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="docutils literal notranslate"><span class="pre">True</span></code> para criar as informações para o refinamento de malha. Ideal para o final do projeto, no qual todas as features já estão definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.rotate">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param">plane</em>, <em class="sig-param">origin</em>, <em class="sig-param">angle</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotacione os pontos governantes de uma superfície de Bézier de forma eficiente em qualquer plano, ao redor de qualquer ponto. Função auxiliadora na hora
da criação de patterns circulares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina em qual plano a rotação será feita. Deve assumir <code class="docutils literal notranslate"><span class="pre">'xy'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xz'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'zy'</span></code>.</p></li>
<li><p><strong>origin</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,float</span></code>) – Defina o ponto que será o centro de rotação.</p></li>
<li><p><strong>angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Assume quantos graus o usuário quer rotacionar sua superfície.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Deverá ser obrigatoriamente chamada entre a função <code class="docutils literal notranslate"><span class="pre">create_point_matrix()</span></code> e a função <code class="docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="creating_solid.set_point_matrix">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">set_point_matrix</code><span class="sig-paren">(</span><em class="sig-param">num_u_points</em>, <em class="sig-param">num_v_points</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.set_point_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinar o número de pontos em cada direção <span class="math notranslate nohighlight">\({u}\)</span> e <span class="math notranslate nohighlight">\({v}\)</span> numa superfície de Bézier.</p>
<p>Caso fique em dúvida da nomenclatura de quais pontos serão necessários setar, execute uma célula (após executar a função em pauta) com <code class="docutils literal notranslate"><span class="pre">print(point_storage)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#exemplo de como tirar a dúvida dos pontos que devem receber algum input</span>
<span class="n">set_point_matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">point_storage</span><span class="p">)</span>
</pre></div>
</div>
<p>Os pontos a serem determinados possuem 2 sub-índices: <span class="math notranslate nohighlight">\({i}\)</span> e <span class="math notranslate nohighlight">\({j}\)</span> → <span class="math notranslate nohighlight">\({P_{ij}}\)</span></p>
<p>Onde <span class="math notranslate nohighlight">\({i}\)</span> corresponde à <span class="math notranslate nohighlight">\({u}\)</span>, <span class="math notranslate nohighlight">\({j}\)</span> corresponde à <span class="math notranslate nohighlight">\({v}\)</span>.</p>
<p>Os sub-índices começarão em <span class="math notranslate nohighlight">\({0}\)</span> e irão até <span class="math notranslate nohighlight">\({i-1}\)</span> and/or <span class="math notranslate nohighlight">\({j-1}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_u_points</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Determine o número de pontos que a direção <span class="math notranslate nohighlight">\({u}\)</span> terá.</p></li>
<li><p><strong>num_v_points</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Determine o número de pontos que a direção <span class="math notranslate nohighlight">\({v}\)</span> terá.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Exemplo:</dt><dd><p>Será explicitado quais pontos deverão ser setados de acordo com as entrys:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_point_matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#função é chamada</span>

<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="c1">#declara-se as coordenadas do ponto</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P01&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="c1">#seja qualquer ponto de 3 coordenadas dentro do domínio ou não</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P20&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P21&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
</pre></div>
</div>
<p>O dicionário <code class="docutils literal notranslate"><span class="pre">point_storage</span></code> faz parte da mecânica do código, não deve ser alterado. Auxilia na setagem e no armazenamento das informações.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.surface_plot">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">surface_plot</code><span class="sig-paren">(</span><em class="sig-param">init_identif</em>, <em class="sig-param">final_identif</em>, <em class="sig-param">engine='matplotlib'</em>, <em class="sig-param">points=False</em>, <em class="sig-param">domain=True</em>, <em class="sig-param">grids=True</em>, <em class="sig-param">legend=True</em>, <em class="sig-param">alpha=0.3</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.surface_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize as superfícies construídas desejadas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init_identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Determine o início do intervalo de superfícies a serem plotadas através da identificação <code class="docutils literal notranslate"><span class="pre">identif</span></code></p></li>
<li><p><strong>final_identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Determine o final do intervalo <strong>(endpoint não incluso)</strong> de superfícies a serem plotadas através da identificação <code class="docutils literal notranslate"><span class="pre">identif</span></code></p></li>
<li><p><strong>engine</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Escolha qual pacote renderizador de plot, <code class="docutils literal notranslate"><span class="pre">'matplotlib'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'mayavi'</span></code>. Mayavi displays better, matplotlib displays more information.</p></li>
<li><p><strong>points</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso queira visualizar os pontos que governam sua superfície, sete como <code class="docutils literal notranslate"><span class="pre">True</span></code>. Válido apenas para <code class="docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso queira deixar de visualizar o domínio, sete como <code class="docutils literal notranslate"><span class="pre">False</span></code>. Válido apenas para <code class="docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>grids</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso queira retirar o grid de background, sete como <code class="docutils literal notranslate"><span class="pre">False</span></code>. Válido apenas para <code class="docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>legends</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso queira retirar as legendas das superfícies, sete como <code class="docutils literal notranslate"><span class="pre">False</span></code>. Válido apenas para <code class="docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional) – Controlador da opacidade da superfície em questão. Pode assumir qualquer valor entre <code class="docutils literal notranslate"><span class="pre">0</span></code> (transparente) e <code class="docutils literal notranslate"><span class="pre">1</span></code> (opaco).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="creating_solid.translate">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">translate</code><span class="sig-paren">(</span><em class="sig-param">direction</em>, <em class="sig-param">quantity</em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Caso tenha se precipitado em relação à posição de sua superfície, translade os pontos governantes de uma superfície de Bézier de forma eficiente
em qualquer direção.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina em qual direção a translação será feita. Deve assumir <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'z'</span></code>.</p></li>
<li><p><strong>quantity</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Assume quantas unidades de comprimento de domínio o usuário quer translate sua superfície.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Deverá ser obrigatoriamente chamada entre a função <code class="docutils literal notranslate"><span class="pre">create_point_matrix()</span></code> e a função <code class="docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code>.</p>
</div>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="examples.html" class="btn btn-neutral float-left" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, André Mombach

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>