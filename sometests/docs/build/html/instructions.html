

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Docstring &mdash; geo_bezier_3d v.0.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Galeria" href="gallery.html" />
    <link rel="prev" title="How To" href="howto.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> geo_bezier_3d
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">ConteÃºdos:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="bezier.html">Abordagem de BÃ©zier</a></li>
<li class="toctree-l1"><a class="reference internal" href="howto.html">How To</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Docstring</a></li>
<li class="toctree-l1"><a class="reference internal" href="gallery.html">Galeria</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">geo_bezier_3d</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Docstring</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/instructions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-creating_solid">
<span id="docstring"></span><span id="instructions"></span><h1>Docstring<a class="headerlink" href="#module-creating_solid" title="Permalink to this headline">Â¶</a></h1>
<p>O usuÃ¡rio recebe nessa pÃ¡gina todas informaÃ§Ãµes dos argumentos de todas as funÃ§Ãµes presentes no cÃ³digo:</p>
<dl class="py function">
<dt id="creating_solid.berstein">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">berstein</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.berstein" title="Permalink to this definition">Â¶</a></dt>
<dd><p>MatemÃ¡tica chave por trÃ¡s das curvas/superfÃ­cies de BÃ©zier, dentro da prÃ³pria funÃ§Ã£o <a class="reference internal" href="#creating_solid.gen_bezier_surface" title="creating_solid.gen_bezier_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) â€“ NÃ£o hÃ¡ necessidade alguma de manipulaÃ§Ã£o por parte do usuÃ¡rio.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.bounds_into_single_solid">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">bounds_into_single_solid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif_list</span></em>, <em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">solid_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.bounds_into_single_solid" title="Permalink to this definition">Â¶</a></dt>
<dd><p>FunÃ§Ã£o que agrega diversas features em apenas um sÃ³lido. Se faz necessÃ¡rio na hora de realizar um mirror atrelado a um â€˜targetâ€™.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif_list</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,strs</span></code>) â€“ Lista dos identificadores das features que farÃ£o parte do sÃ³lido. Deve assumir [identif n,identif n+1,â€¦].</p></li>
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code>.</p></li>
<li><p><strong>solid_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.create_point_matrix">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">create_point_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deflection</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.create_point_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>AuxÃ­lio na hora de setar os pontos necessÃ¡rios para as equaÃ§Ãµes da funÃ§Ã£o <a class="reference internal" href="#creating_solid.gen_bezier_surface" title="creating_solid.gen_bezier_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>deflection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> caso queira que a superfÃ­cie passe necessariamente pelos pontos de controle
(pontos intermediÃ¡rios, os que normalmente dÃ£o a curvatura suave Ã  superfÃ­cie). Baseia-se num artifÃ­cio
matemÃ¡tico que <em>hackeia</em> a BÃ©zier, forÃ§ando-a a fazer algo que normalmente nÃ£o faria.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">deflection=True</span></code> <strong>nÃ£o demonstrarÃ¡ efeito em todos os casos!</strong></p>
<p>O parÃ¢metro pode ficar setado como True sem danificar o cÃ³digo, porÃ©m sÃ³ efetivamente desviarÃ¡ a superfÃ­cie
caso <code class="xref py py-obj docutils literal notranslate"><span class="pre">n_num_u_points=3</span></code> ao mesmo tempo que <code class="xref py py-obj docutils literal notranslate"><span class="pre">n_num_v_points=2</span></code> ou vice-versa.</p>
<p><strong>O porquÃª da restriÃ§Ã£o:</strong></p>
<p>Como pode-se imaginar, nÃ£o hÃ¡ necessidade de desviar a superfÃ­cie para passar em pontos intermediÃ¡rios caso existam apenas 2
pontos na direÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code> pois nÃ£o hÃ¡ pontos intermediÃ¡rios. TambÃ©m, caso a superfÃ­cie tenha 3 pontos em cada direÃ§Ã£o
<code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code> ou mais, torna-se <em>matematicamente complicado</em> descrever o desvio.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.epsi_plot">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">epsi_plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ticks</span><span class="o">=</span><span class="default_value">'full'</span></em>, <em class="sig-param"><span class="n">integral</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">raf</span><span class="o">=</span><span class="default_value">'normal'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.epsi_plot" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Confira se os limites estÃ£o corretos, camada por camada ou por amostragem, em qualquer direÃ§Ã£o.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ PoderÃ¡ assumir os seguintes valores: <code class="xref py py-obj docutils literal notranslate"><span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z'</span></code>.</p></li>
<li><p><strong>grid</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Caso houver nÃºmero demasiado de nÃ³s (&gt;250), setar como <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code> auxiliarÃ¡ na visualizaÃ§Ã£o.</p></li>
<li><p><strong>ticks</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) â€“ DefiniÃ§Ã£o dos ticks da imagem (nÃºmeros que acompanham os eixos). Pode assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code> (ideal para poucos nÃ³s), <code class="xref py py-obj docutils literal notranslate"><span class="pre">some</span></code> (ideal para nÃºmero alto de nÃ³s), <code class="xref py py-obj docutils literal notranslate"><span class="pre">none</span></code></p></li>
<li><p><strong>limpa</strong><strong>)</strong><strong></strong> (<em>(</em><em>imagem</em>) â€“ </p></li>
<li><p><strong>integral</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Se o usuÃ¡rio quiser conferir meticulosamente todas as camadas, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>raf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) â€“ Se o usuÃ¡rio quiser conferir alguma Epsi Refinada, setar com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'x','y','z'</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_bezier_surface">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_bezier_surface</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">show_equation</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_bezier_surface" title="Permalink to this definition">Â¶</a></dt>
<dd><p>As equaÃ§Ãµes de BÃ©zier sÃ£o governadas pelos parÃ¢metros <code class="xref py py-obj docutils literal notranslate"><span class="pre">u</span></code> e <code class="xref py py-obj docutils literal notranslate"><span class="pre">v</span></code> e fornecem leis para curvas/superfÃ­cies.</p>
<p>SÃ£o definidas por pontos arbitrados pelo usuÃ¡rio, tendo um mÃ­nimo de 2 em cada direÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code> e sem algum mÃ¡ximo prÃ©-determinado.</p>
<p>Os pontos iniciais e finais determinam onde a curva comeÃ§a e termina, obviamente. <em>SÃ£o os Ãºnicos pontos por onde a BÃ©zier (naturalmente) passarÃ¡ com certeza</em>.
Os pontos intermediÃ¡rios estÃ£o encarregados de fornecer Ã  BÃ©zier uma curvatura suave, sem canto vivo/descontinuidade,
portanto a curva/superfÃ­cie nunca <em>encosta</em> neles (para burlar essa situaÃ§Ã£o, veja a funÃ§Ã£o <a class="reference internal" href="#creating_solid.create_point_matrix" title="creating_solid.create_point_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_point_matrix()</span></code></a>).</p>
<p>O grau das equaÃ§Ãµes Ã© definido por <code class="xref py py-obj docutils literal notranslate"><span class="pre">nÃºmero</span> <span class="pre">de</span> <span class="pre">pontos</span> <span class="pre">definidos</span> <span class="pre">pelo</span> <span class="pre">usuÃ¡rio</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da sua superfÃ­cie com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code> (comeÃ§ar em â€˜0â€™ e somar â€˜1â€™ a cada nova superfÃ­cie).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie um name para a superfÃ­cie. NÃ£o hÃ¡ regras.</p></li>
<li><p><strong>show_equations</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> caso queira visualizar as equaÃ§Ãµes governantes da superfÃ­cie em questÃ£o.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">identif()</span></code> <strong>necessita atenÃ§Ã£o especial</strong>: o usuÃ¡rio voltarÃ¡ a chamar o parÃ¢metro por diversas vezes ao decorrer do cÃ³digo.</p>
</div>
<p>Ã‰ importante frisar que, caso construÃ­da uma superfÃ­cie muito complexa (com variaÃ§Ãµes nÃ£o lineares entre os pontos em mais de 2 direÃ§Ãµes <code class="xref py py-obj docutils literal notranslate"><span class="pre">xyz</span></code>, uma
superfÃ­cie muito torcida), a convergÃªncia das equaÃ§Ãµes nÃ£o Ã© garantida.</p>
<a class="reference internal image-reference" href="_images/ex_supcomplexa.png"><img alt="_images/ex_supcomplexa.png" class="align-right" src="_images/ex_supcomplexa.png" style="width: 279.2px; height: 266.40000000000003px;" /></a>
<p>A superfÃ­cie ao lado possui seguintes equaÃ§Ãµes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(ğ‘¢,ğ‘£) = 4ğ‘¢Â²âˆ’2ğ‘¢+ğ‘£Â²(3ğ‘¢2âˆ’6ğ‘¢+3)+ğ‘£(âˆ’6ğ‘¢Â²+12ğ‘¢âˆ’6)+3

y(ğ‘¢,ğ‘£) = 2ğ‘¢Â²+ğ‘£Â²(2ğ‘¢Â²+1)+ğ‘£(4âˆ’4ğ‘¢Â²)

z(ğ‘¢,ğ‘£) = âˆ’3ğ‘¢Â²+4ğ‘¢+ğ‘£Â²(âˆ’11ğ‘¢Â²+14ğ‘¢âˆ’7)+ğ‘£(18ğ‘¢Â²âˆ’20ğ‘¢+10)
</pre></div>
</div>
<p>Evidentemente, sÃ£o equaÃ§Ãµes longas, nÃ£o lineares e dependentes de mais de uma variÃ¡vel. O solver nÃ£o se dÃ¡ muito bem com isso. O usuÃ¡rio pode tentar a sorte, simplificar a superfÃ­cie ou tentar outro tipo de solver na hora de gerar a matriz Epsi na funÃ§Ã£o <a class="reference internal" href="#creating_solid.gen_epsi_bezier_surface" title="creating_solid.gen_epsi_bezier_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi_bezier_surface()</span></code></a>. $/epsi$ /epsi $epsi$ epsi.</p>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_cylinder">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_cylinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">bases_plane</span></em>, <em class="sig-param"><span class="n">radius</span></em>, <em class="sig-param"><span class="n">center_1</span></em>, <em class="sig-param"><span class="n">center_2</span></em>, <em class="sig-param"><span class="n">init_height</span></em>, <em class="sig-param"><span class="n">final_height</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_cylinder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Crie um cilÃ­ndro ao longo de x, y ou z em qualquer ponto do domÃ­nio. NÃ£o hÃ¡ possibilidade de rotaÃ§Ãµes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code>.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie um nome para a feature. NÃ£o hÃ¡ regras.</p></li>
<li><p><strong>bases_plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ O plano transversal ao cilindro: onde a base ou o topo ficam (sÃ£o paralelos).</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Raio da base/topo.</p></li>
<li><p><strong>center1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ 1Âª coordenada do centro da base/topo. O eixo correspondende Ã  coordenada dependerÃ¡ de qual <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>center2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ 2Âª coordenada do centro da base/topo. O eixo correspondende Ã  coordenada dependerÃ¡ de qual <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ InÃ­cio do cilindro. Deve ser menor do que <code class="xref py py-obj docutils literal notranslate"><span class="pre">final_height</span></code>.</p></li>
<li><p><strong>final_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Final do cilindro. Deve ser maior do que <code class="xref py py-obj docutils literal notranslate"><span class="pre">init_height</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_bezier_surface">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_bezier_surface</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">surface_type</span></em>, <em class="sig-param"><span class="n">plane</span></em>, <em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">'scipy'</span></em>, <em class="sig-param"><span class="n">add_or_sub</span><span class="o">=</span><span class="default_value">'add'</span></em>, <em class="sig-param"><span class="n">interval</span><span class="o">=</span><span class="default_value">numpy.arange</span></em>, <em class="sig-param"><span class="n">bez_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_bezier_surface" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Nesta funÃ§Ã£o, usamos as equaÃ§Ãµes geradas pelos pontos fornecidos pelo usuÃ¡rio para setar os limites de onde Ã© solid (na Epsi, <code class="xref py py-obj docutils literal notranslate"><span class="pre">1</span></code>) e onde
nÃ£o Ã© solid (na Epsi, <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code>). Vamos setar o que Ã© considerado entry e exit, ou ambos ao mesmo tempo, <strong>para todas as superfÃ­cies criadas</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ <p>Defina se a superfÃ­cie em questÃ£o Ã© considerada uma entry, uma exit ou ambos em relaÃ§Ã£o ao solid.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>surface_type</p></th>
<th class="head"><p>Set <code class="xref py py-obj docutils literal notranslate"><span class="pre">surface_type</span></code> as</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>entry</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">entry'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>exit</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">exit'</span></code></p></td>
</tr>
<tr class="row-even"><td><p>entry/exit</p></td>
<td><p>whatever</p></td>
</tr>
<tr class="row-odd"><td><p>entry/exit + entry</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">entry'</span></code></p></td>
</tr>
<tr class="row-even"><td><p>entry/exit + exit</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entry+exit</span> <span class="pre">and/or</span> <span class="pre">exit'</span></code></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Escolha o melhor plane para resolver sua superfÃ­cie. Caso o plane xy seja o melhor, setar <code class="xref py py-obj docutils literal notranslate"><span class="pre">plane='xy'</span></code>. Pode assumir apenas <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xz','xy','zy'</span></code>. Uma superfÃ­cie plana e paralela a um plano nÃ£o pode ser resolvida por esse plano pois nÃ£o tem dimensÃ£o em relaÃ§Ã£o ao plano.</p></li>
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> da superfÃ­cie em questÃ£o.</p></li>
<li><p><strong>solver</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) â€“ Deve assumir â€˜scipyâ€™ or â€˜sympyâ€™. Normalmente â€˜scipyâ€™ Ã© mais eficiente e barato.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina o mecanismo de criaÃ§Ã£o da Epsi. Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informaÃ§Ã£o da superfÃ­cie para a Epsi serÃ¡ atravÃ©s de adiÃ§Ã£o (ou subtraÃ§Ã£o, caso seja uma <code class="xref py py-obj docutils literal notranslate"><span class="pre">entry/exit</span> <span class="pre">and/or</span> <span class="pre">exit</span></code>), caso ideal para obtenÃ§Ã£o de intersecÃ§Ãµes (nÃ£o esquecer de usar a funÃ§Ã£o <a class="reference internal" href="#creating_solid.normalize_epsi" title="creating_solid.normalize_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_epsi()</span></code></a> para correÃ§Ã£o). Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo serÃ¡ atravÃ©s de substituiÃ§Ã£o (metodologia padrÃ£o).</p></li>
<li><p><strong>interval</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,</span> <span class="pre">np.arange</span></code>, optional) â€“ Intervalo no qual o solver â€˜scipyâ€™ vai buscar as raÃ­zes. O padrÃ£o Ã© o que apresenta melhores resultados.</p></li>
<li><p><strong>bez_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt><strong>Exemplo:</strong></dt><dd><div class="figure align-center">
<a class="reference internal image-reference" href="_images/ex_entradasaidasaida.png"><img alt="_images/ex_entradasaidasaida.png" src="_images/ex_entradasaidasaida.png" style="width: 491.4px; height: 489.99999999999994px;" /></a>
</div>
<p>Podemos notar 2 supefÃ­cies na figura, uma verde (<code class="xref py py-obj docutils literal notranslate"><span class="pre">identif='0'</span></code>) e outra roxa (<code class="xref py py-obj docutils literal notranslate"><span class="pre">identif='1'</span></code>).
De acordo com esta situaÃ§Ã£o, a invocaÃ§Ã£o da funÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi()</span></code> pode se dar na seguinte forma:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen_epsi</span><span class="p">(</span><span class="s1">&#39;entry+exit and/or entry&#39;</span><span class="p">,</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">gen_epsi</span><span class="p">(</span><span class="s1">&#39;entry+exit and/or exit&#39;</span><span class="p">,</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Podemos notar tambÃ©m um ponto que Ã© o inÃ­cio de um vetor perpendicular ao plane â€˜zyâ€™. Este vetor Ã© a representaÃ§Ã£o do que define o <code class="xref py py-obj docutils literal notranslate"><span class="pre">surface_type</span></code> de cada superfÃ­cie.
Toda vez que o vetor encontrar alguma superfÃ­cies, serÃ¡ definido um limite para a criaÃ§Ã£o da Epsi.
Devemos imaginar que para cada combinaÃ§Ã£o de coordenada â€˜zâ€™ e â€˜yâ€™ (espaÃ§amento definido por dz e dy) um vetor desses Ã© originado. Portanto:</p>
<blockquote>
<div><p>1. O sÃ³lido verde Ã© considerado <em>entry Pura</em> pois, no instante em que Ã© interceptado pelos vetores,
<strong>entra-se no sÃ³lido</strong>.</p>
<p>2. O sÃ³lido roxo deve ser dividido em 2 partes e Ã© considerado <em>entry/exit + exit</em>. A primeira parte Ã© a superior, logo acima da superfÃ­cie verde.
Toda esta parte serÃ¡ interceptada pelos vetores duas vezes e <strong>por isso Ã© considerada entry/exit</strong>. A segunda parte Ã© a inferior, que â€˜compartilhaâ€™
altura com a superfÃ­cie verde. Esta parte serÃ¡ interceptada pelos vetores apenas uma vez e em todas elas o sÃ³lido jÃ¡ terÃ¡ acabado, por isso Ã© considerada
como <strong>exit</strong>.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Caso construÃ­da uma superfÃ­cie que possua segmentos com possÃ­veis entrys/exits simultÃ¢neas (superfÃ­cie roxa), certificar que a superfÃ­cie seja construÃ­da
no sentido positivo: os pontos iniciais devem ser mais prÃ³ximos da origem do que os pontos finais, independente do plane.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_cylinder">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_cylinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">surface_type</span></em>, <em class="sig-param"><span class="n">add_or_sub</span><span class="o">=</span><span class="default_value">'sub'</span></em>, <em class="sig-param"><span class="n">cyl_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_cylinder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o da Epsi da esfera criada anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> do cilindro em questÃ£o.</p></li>
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina se o cilindro serÃ¡ um objeto (adiÃ§Ã£o de â€œmaterialâ€) ou um contorno (subtraÃ§Ã£o de â€œmaterialâ€) . Deve assumir â€˜solidâ€™ ou â€˜contourâ€™.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina o mecanismo de criaÃ§Ã£o da Epsi. Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informaÃ§Ã£o da superfÃ­cie para a Epsi serÃ¡ atravÃ©s de adiÃ§Ã£o (ou subtraÃ§Ã£o, caso seja um <code class="xref py py-obj docutils literal notranslate"><span class="pre">contour</span></code>), caso ideal para obtenÃ§Ã£o de intersecÃ§Ãµes (nÃ£o esquecer de usar a funÃ§Ã£o <a class="reference internal" href="#creating_solid.normalize_epsi" title="creating_solid.normalize_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_epsi()</span></code></a> para correÃ§Ã£o). Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo serÃ¡ atravÃ©s de substituiÃ§Ã£o (metodologia padrÃ£o).</p></li>
<li><p><strong>cyl_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_extrude">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_extrude</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">ext_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_extrude" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o da Epsi do Extrude criado anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> do extrude em questÃ£o.</p></li>
<li><p><strong>ext_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_mirror">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_mirror</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target</span></em>, <em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">mirror_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_mirror" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Espelhe o domÃ­nio inteiro ou apenas um sÃ³lido construÃ­do com <a class="reference internal" href="#creating_solid.bounds_into_single_solid" title="creating_solid.bounds_into_single_solid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds_into_single_solid()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Pode assumir â€˜whole_domainâ€™ (caso o mirror seja feito ao longo de todo domÃ­nio) ou a identificaÃ§Ã£o do sÃ³lido criado com <a class="reference internal" href="#creating_solid.bounds_into_single_solid" title="creating_solid.bounds_into_single_solid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds_into_single_solid()</span></code></a> (caso mirror seja feito em apenas uma parte do domÃ­nio).</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ DireÃ§Ã£o na qual o mirror serÃ¡ efetuado. Deve assumir â€˜xâ€™, â€˜yâ€™ ou â€˜zâ€™.</p></li>
<li><p><strong>mirror_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_quad_prism">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_quad_prism</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">surface_type</span></em>, <em class="sig-param"><span class="n">add_or_sub</span><span class="o">=</span><span class="default_value">'sub'</span></em>, <em class="sig-param"><span class="n">qp_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_quad_prism" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o da Epsi do prisma criado anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> do cubÃ³ide em questÃ£o.</p></li>
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina se o cubÃ³ide serÃ¡ um objeto (adiÃ§Ã£o de â€œmaterialâ€) ou um contorno (subtraÃ§Ã£o de â€œmaterialâ€) . Deve assumir â€˜solidâ€™ ou â€˜contourâ€™.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina o mecanismo de criaÃ§Ã£o da Epsi. Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informaÃ§Ã£o da superfÃ­cie para a Epsi serÃ¡ atravÃ©s de adiÃ§Ã£o (ou subtraÃ§Ã£o, caso seja um <code class="xref py py-obj docutils literal notranslate"><span class="pre">contour</span></code>), caso ideal para obtenÃ§Ã£o de intersecÃ§Ãµes (nÃ£o esquecer de usar a funÃ§Ã£o <a class="reference internal" href="#creating_solid.normalize_epsi" title="creating_solid.normalize_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_epsi()</span></code></a> para correÃ§Ã£o). Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo serÃ¡ atravÃ©s de substituiÃ§Ã£o (metodologia padrÃ£o).</p></li>
<li><p><strong>qp_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_revolve">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_revolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_revolve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o da Epsi do Revolve criado anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> do revolve em questÃ£o.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_sphere">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_sphere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">surface_type</span></em>, <em class="sig-param"><span class="n">add_or_sub</span><span class="o">=</span><span class="default_value">'sub'</span></em>, <em class="sig-param"><span class="n">sph_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_sphere" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o da Epsi da esfera criada anteriormente.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> da esfera em questÃ£o.</p></li>
<li><p><strong>surface_type</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina se a esfera serÃ¡ um objeto (adiÃ§Ã£o de â€œmaterialâ€) ou um contorno (subtraÃ§Ã£o de â€œmaterialâ€) . Deve assumir â€˜solidâ€™ ou â€˜contourâ€™.</p></li>
<li><p><strong>add_or_sub</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina o mecanismo de criaÃ§Ã£o da Epsi. Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'add'</span></code>, o fluxo de informaÃ§Ã£o da superfÃ­cie para a Epsi serÃ¡ atravÃ©s de adiÃ§Ã£o (ou subtraÃ§Ã£o, caso seja um <code class="xref py py-obj docutils literal notranslate"><span class="pre">contour</span></code>), caso ideal para obtenÃ§Ã£o de intersecÃ§Ãµes (nÃ£o esquecer de usar a funÃ§Ã£o <a class="reference internal" href="#creating_solid.normalize_epsi" title="creating_solid.normalize_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_epsi()</span></code></a> para correÃ§Ã£o). Caso assuma <code class="xref py py-obj docutils literal notranslate"><span class="pre">'sub'</span></code>, o fluxo serÃ¡ atravÃ©s de substituiÃ§Ã£o (metodologia padrÃ£o).</p></li>
<li><p><strong>sph_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_extrude_profile">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_extrude_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">init_height</span></em>, <em class="sig-param"><span class="n">final_height</span></em>, <em class="sig-param"><span class="n">deflection</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ext_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_extrude_profile" title="Permalink to this definition">Â¶</a></dt>
<dd><p>CriaÃ§Ã£o de um perfil que serÃ¡ posteriormente extrudado. O input da funÃ§Ã£o deve assumir a seguinte forma de um dicionÃ¡rio:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#forma geral</span>

<span class="n">c</span><span class="o">.</span><span class="n">extrude_information</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;#0 identif&#39;</span><span class="p">:[</span><span class="s1">&#39;line type&#39;</span><span class="p">,</span><span class="s1">&#39;direÃ§Ã£o da soluÃ§Ã£o&#39;</span><span class="p">,[</span><span class="n">pontos</span> <span class="n">de</span> <span class="n">controle</span><span class="p">]],</span>
                       <span class="s1">&#39;#1 identif&#39;</span><span class="p">:[</span><span class="s1">&#39;line type&#39;</span><span class="p">,</span><span class="s1">&#39;direÃ§Ã£o da soluÃ§Ã£o&#39;</span><span class="p">,[</span><span class="n">pontos</span> <span class="n">de</span> <span class="n">controle</span><span class="p">]]}</span>

<span class="c1">#forma aplicada</span>

<span class="n">c</span><span class="o">.</span><span class="n">extrude_information</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:[</span><span class="s1">&#39;entry+exit and/or exit&#39;</span> <span class="p">,</span><span class="s1">&#39;v&#39;</span><span class="p">,[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]]],</span>
                       <span class="s1">&#39;0&#39;</span><span class="p">:[</span><span class="s1">&#39;entry+exit and/or entry&#39;</span><span class="p">,</span><span class="s1">&#39;v&#39;</span><span class="p">,[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]]]}</span>
</pre></div>
</div>
<p>A key do dicionÃ¡rio, <code class="xref py py-obj docutils literal notranslate"><span class="pre">'#0</span> <span class="pre">identif'</span></code>, Ã© o identificador da curva criada. TambÃ©m tambÃ©m carrega a funÃ§Ã£o de determinar a ordem em que as curvas serÃ£or resolvidas (<em>normalmente</em>
o usuÃ¡rio vai querer resolver primeiro todas as entradas);</p>
<p>O primeiro termo da lista do dicionÃ¡rio, â€˜line typeâ€™, determina que tipo de limite a curva em questÃ£o Ã© - entrada ou saÃ­da. Deve assumir â€˜entry+exit and/or exitâ€™ ou
â€˜entry+exit and/or entryâ€™;</p>
<p>O segundo termo da lista do dicionÃ¡rio - â€˜direÃ§Ã£o da soluÃ§Ã£oâ€™ - pode assumir â€˜vâ€™ ou â€˜hâ€™, que significam vertical e horizontal, respectivamente. Caso seja escolhido vertical,
para cada nÃ³ no eixo vertical serÃ¡ disparado um vetor que interceptarÃ¡ as curvas. Caso essa curva seja entrada, a partir dessa intersecÃ§Ã£o o algorÃ­tmo interpretarÃ¡ como dentro do
perfil de extrude. Caso essa curva seja saÃ­da, o algorÃ­tmo interpretarÃ¡ como fora do perfil de extrude.</p>
<p>O terceiro e Ãºltimo termo do dicionÃ¡rio Ã© uma lista, â€˜[pontos de controle]â€™, contendo todos os pontos de controle de cada curva de BÃ©zier que setarÃ¡ o perfil de extrude.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Nessa funÃ§Ã£o, as curvas de BÃ©zier podem ser solucionadas na direÃ§Ã£o do eixo horizontal (da esquerda para a direita) ou pelo eixo vertical (de baixo para cima). Essa configuraÃ§Ã£o Ã© definida pelo termo â€˜direÃ§Ã£o da soluÃ§Ã£oâ€™, que pode assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'h'</span></code> ou <code class="xref py py-obj docutils literal notranslate"><span class="pre">'v'</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code> (comeÃ§ar em â€˜0â€™ e somar â€˜1â€™ a cada nova superfÃ­cie).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie um name para a feature. NÃ£o hÃ¡ regras.</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ DireÃ§Ã£o na qual o extrude ocorrerÃ¡. Deve assumir â€˜xâ€™, â€˜yâ€™ ou â€˜zâ€™.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ InÃ­cio do extrude, relacionado Ã  <code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code>.</p></li>
<li><p><strong>final_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Final do extrude, relacionado Ã  <code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code>.</p></li>
<li><p><strong>deflection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> caso queira que a curva passe pelo ponto de controle intermediÃ¡rio (o que normalmente dÃ¡ curvatura suave Ã  curva). Baseia-se num artifÃ­cio matemÃ¡tico que <em>hackeia</em> a BÃ©zier, forÃ§ando-a a fazer algo que normalmente nÃ£o faria. Funcional apenas para curvas com 3 pontos.</p></li>
<li><p><strong>ext_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_output">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">names</span></em>, <em class="sig-param"><span class="n">out_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_output" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o dos arquivos de saÃ­da. Tornam possÃ­vel a visualizaÃ§Ã£o no ParaView da Epsi, bem como a resoluÃ§Ã£o das equaÃ§Ãµes
de Navier Stokes nas redondezas do sÃ³lido criado.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Entre com o name que serÃ¡ dado aos arquivos gerado pelo programa.</p></li>
<li><p><strong>raf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ NÃ£o hÃ¡ necessidade alguma de manipulaÃ§Ã£o por parte do usuÃ¡rio.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_quad_prism">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_quad_prism</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">reference_point</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_quad_prism" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Crie um cubÃ³ide (prisma quadrangular) em qualquer posiÃ§Ã£o do domÃ­nio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code>.</p></li>
<li><p><strong>a</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Aresta na direÃ§Ã£o de x.</p></li>
<li><p><strong>b</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Aresta na direÃ§Ã£o de y.</p></li>
<li><p><strong>c</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Aresta na direÃ§Ã£o de z.</p></li>
<li><p><strong>reference_point</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,</span> <span class="pre">float</span></code>) â€“ Coordenadas do ponto de referÃªncia para posicionamento do cubÃ³ide. Ã‰ o vÃ©rtice mais prÃ³ximo da origem do plano cartesiano.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_raf_information">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_raf_information</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nraf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_raf_information" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GeraÃ§Ã£o de informaÃ§Ãµes para Epsi refinada, importante arquivo para o <code class="xref py py-obj docutils literal notranslate"><span class="pre">Incompact3d</span></code>. O objetivo Ã© obter maior precisÃ£o em cada dimensÃ£o por vez.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nraf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) â€“ Entre com o nÃºmero de vezes que gostaria de multiplicar os nÃ³s (refinar a malha).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_revolve_profile">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_revolve_profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">center_1</span></em>, <em class="sig-param"><span class="n">center_2</span></em>, <em class="sig-param"><span class="n">init_height</span></em>, <em class="sig-param"><span class="n">deflection</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rev_raf_path</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">toroid</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_revolve_profile" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Construa um perfil de revolve por meio de curvas de BÃ©zier sempre no sentido positivo, sem idas e voltas (cada â€˜axisâ€™ so pode ter 1 â€˜radiusâ€™). Primeiro ponto de ambos limites (superior e inferior) sempre deve ser 0. Perfil superior e perfil inferior devem terminar no mesmo ponto.</p>
<p>Para confirmar a efetividade da funÃ§Ã£o, checar que dentro da Ã¡rea do perfil de revolve (Ã¡rea limitada pelo perfil superior e inferior), para toda linha vermelha â€˜â€“â€™ deve existir uma linha cinza â€˜-â€˜.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Nessa funÃ§Ã£o, diferentemente da funÃ§Ã£o <a class="reference internal" href="#creating_solid.gen_extrude_profile" title="creating_solid.gen_extrude_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_extrude_profile()</span></code></a>, as curvas de BÃ©zier serÃ£os sempre solucionadas na direÃ§Ã£o do eixo vertical, de baixo para cima.</p>
</div>
<p>As informaÃ§Ãµes de entrada para as curvas devem ser feitas da seguinte forma (em dicionÃ¡rio):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#forma geral</span>

<span class="n">c</span><span class="o">.</span><span class="n">inferior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;n&#39;</span><span class="p">:</span>  <span class="p">[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                         <span class="s1">&#39;n+1&#39;</span><span class="p">:[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                        <span class="p">}</span>

<span class="n">c</span><span class="o">.</span><span class="n">superior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;n&#39;</span><span class="p">:</span>  <span class="p">[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                         <span class="s1">&#39;n+1&#39;</span><span class="p">:[[</span><span class="n">lista</span> <span class="n">de</span> <span class="n">p</span> <span class="n">pontos</span><span class="p">]],</span>
                        <span class="p">}</span>

<span class="c1">#forma aplicada</span>

<span class="n">c</span><span class="o">.</span><span class="n">inferior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;0&#39;</span><span class="p">:[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]],</span>
                         <span class="s1">&#39;1&#39;</span><span class="p">:[[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]]],</span>
                         <span class="s1">&#39;2&#39;</span><span class="p">:[[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">]]]</span>
                        <span class="p">}</span>

<span class="n">c</span><span class="o">.</span><span class="n">superior_revolve_info</span><span class="o">=</span><span class="p">{</span>
                         <span class="s1">&#39;0&#39;</span><span class="p">:[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]],</span>
                         <span class="s1">&#39;1&#39;</span><span class="p">:[[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]],</span>
                         <span class="s1">&#39;2&#39;</span><span class="p">:[[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]]],</span>
                         <span class="s1">&#39;3&#39;</span><span class="p">:[[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]]]</span>
                        <span class="p">}</span>
</pre></div>
</div>
<p>A key do dicionÃ¡rio, n, deve comeÃ§ar em 0 e aumentar 1 toda vez que uma nova curva for adicionada;</p>
<p>O termo do prÃ³prio dicionÃ¡rio deve ser uma lista de p pontos, onde p pode assumir valores diferentes para cada curva (mÃ­nimo 2 e mÃ¡ximo (recomendado) 5);</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code>.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie um nome para a feature. NÃ£o hÃ¡ regras.</p></li>
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ DireÃ§Ã£o longitudinal do revolve.</p></li>
<li><p><strong>center_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ 1Âª coordenada do centro da base/topo. O eixo correspondende Ã  coordenada dependerÃ¡ de qual <code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code> foi definido.</p></li>
<li><p><strong>center_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ 2Âª coordenada do centro da base/topo. O eixo correspondende Ã  coordenada dependerÃ¡ de qual <code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code> foi definido.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ InÃ­cio do revolve.</p></li>
<li><p><strong>deflection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> caso queira que a curva passe pelo ponto de controle intermediÃ¡rio (o que normalmente dÃ¡ curvatura suave Ã  curva). Baseia-se num artifÃ­cio matemÃ¡tico que <em>hackeia</em> a BÃ©zier, forÃ§ando-a a fazer algo que normalmente nÃ£o faria. Funcional apenas para curvas com 3 pontos.</p></li>
<li><p><strong>rev_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
<li><p><strong>toroid</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ NÃ£o hÃ¡ necessidade alguma de manipulaÃ§Ã£o por parte do usuÃ¡rio.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_sphere">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_sphere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">radius</span></em>, <em class="sig-param"><span class="n">cex</span></em>, <em class="sig-param"><span class="n">cey</span></em>, <em class="sig-param"><span class="n">cez</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_sphere" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Crie uma esfera em qualquer posiÃ§Ã£o do domÃ­nio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code> (comeÃ§ar em â€˜0â€™ e somar â€˜1â€™ a cada nova superfÃ­cie).</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie um nome para a feature. NÃ£o hÃ¡ regras.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Raio da esfera.</p></li>
<li><p><strong>cex</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Coordenada x do centro.</p></li>
<li><p><strong>cey</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Coordenada y do centro.</p></li>
<li><p><strong>cez</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Coordenada z do centro.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_toroid">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_toroid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">bases_plane</span></em>, <em class="sig-param"><span class="n">external_radius</span></em>, <em class="sig-param"><span class="n">profile_circle_radius</span></em>, <em class="sig-param"><span class="n">center_1</span></em>, <em class="sig-param"><span class="n">center_2</span></em>, <em class="sig-param"><span class="n">init_height</span></em>, <em class="sig-param"><span class="n">tor_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_toroid" title="Permalink to this definition">Â¶</a></dt>
<dd><p>FunÃ§Ã£o facilitadora para criaÃ§Ã£o de um torÃ³ide por meio da funÃ§Ã£o obj:<cite>gen_revolve_profile()</cite>. NÃ£o necessita de informaÃ§Ãµes (dicionÃ¡rio) de entrada.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie a <em>identificaÃ§Ã£o</em> da feature com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code>.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Crie um nome para a feature. NÃ£o hÃ¡ regras.</p></li>
<li><p><strong>bases_plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ O plano transversal ao torÃ³ide, plano no qual o cÃ­rculo central Ã© paralelo.</p></li>
<li><p><strong>external_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Raio total do torÃ³ide, o ponto mais externo.</p></li>
<li><p><strong>profile_circle_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ Raio do perfil circular transversal do torÃ³ide.</p></li>
<li><p><strong>center_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ 1Âª coordenada do centro da base/topo. O eixo correspondende Ã  coordenada dependerÃ¡ de qual <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>center_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ 2Âª coordenada do centro da base/topo. O eixo correspondende Ã  coordenada dependerÃ¡ de qual <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code> foi definido.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) â€“ InÃ­cio do torÃ³ide na direÃ§Ã£o perpendicular ao <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code> definido.</p></li>
<li><p><strong>tor_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.normalize_epsi">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">normalize_epsi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intersection</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">epsi_raf_path</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.normalize_epsi" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Ideal chamar essa funÃ§Ã£o antes de gerar os arquivos de saÃ­da. Corrige qualquer valor inadequado da Epsi (menor do que 0 ou maior do que 1) que podem ser gerados ao decorrer do projeto.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intersection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ </p></li>
<li><p><strong>target</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ </p></li>
<li><p><strong>epsi_raf_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> para criar as informaÃ§Ãµes para o refinamento de malha. Ideal para o final do projeto, no qual todas as features jÃ¡ estÃ£o definidas.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.rotate">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plane</span></em>, <em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">angle</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.rotate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Rotacione os pontos governantes de uma superfÃ­cie de BÃ©zier de forma eficiente em qualquer plano, ao redor de qualquer ponto. FunÃ§Ã£o auxiliadora na hora
da criaÃ§Ã£o de patterns circulares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina em qual plano a rotaÃ§Ã£o serÃ¡ feita. Deve assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xy'</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xz'</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">'zy'</span></code>.</p></li>
<li><p><strong>origin</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list,float</span></code>) â€“ Defina o ponto que serÃ¡ o centro de rotaÃ§Ã£o.</p></li>
<li><p><strong>angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) â€“ Assume quantos graus o usuÃ¡rio quer rotacionar sua superfÃ­cie.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>DeverÃ¡ ser obrigatoriamente chamada entre a funÃ§Ã£o <a class="reference internal" href="#creating_solid.create_point_matrix" title="creating_solid.create_point_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_point_matrix()</span></code></a> e a funÃ§Ã£o <a class="reference internal" href="#creating_solid.gen_bezier_surface" title="creating_solid.gen_bezier_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code></a>.</p>
</div>
<p>Exemplo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_point_matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P01&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>

<span class="n">create_point_matrix</span><span class="p">()</span>

<span class="n">rotate</span><span class="p">(</span><span class="s1">&#39;xy&#39;</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">30</span><span class="p">)</span>

<span class="n">gen_bezier_surface</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;nome_qualquer_para_a_superfÃ­cie&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.set_point_matrix">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">set_point_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_u_points</span></em>, <em class="sig-param"><span class="n">num_v_points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.set_point_matrix" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Importante funÃ§Ã£o em que o usuÃ¡rio determinarÃ¡ o nÃºmero de pontos em cada direÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code>.</p>
<p>Caso fique em dÃºvida da namenclatura de quais pontos serÃ£o necessÃ¡rios setar, execute uma cÃ©lula (apÃ³s executar a funÃ§Ã£o em pauta) com <code class="xref py py-obj docutils literal notranslate"><span class="pre">print(point_storage)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#exemplo de como tirar a dÃºvida dos pontos que devem receber algum input</span>
<span class="n">set_point_matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">point_storage</span><span class="p">)</span>
</pre></div>
</div>
<p>Basicamente, os pontos a serem determinados possuem 2 sub-Ã­ndices: <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code> e <code class="xref py py-obj docutils literal notranslate"><span class="pre">j</span></code> â†’ <code class="xref py py-obj docutils literal notranslate"><span class="pre">Pij</span></code>.</p>
<p>Os sub-Ã­ndices comeÃ§arÃ£o em <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code> e irÃ£o atÃ© <code class="xref py py-obj docutils literal notranslate"><span class="pre">i-1</span></code> and/or <code class="xref py py-obj docutils literal notranslate"><span class="pre">j-1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_u_points</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) â€“ Determine o nÃºmero de pontos que a direÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">u</span></code> terÃ¡.</p></li>
<li><p><strong>num_v_points</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) â€“ Determine o nÃºmero de pontos que a direÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">v</span></code> terÃ¡.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Exemplo:</dt><dd><p>SerÃ¡ explicitado quais pontos deverÃ£o ser setados de acordo com as entrys:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_point_matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#funÃ§Ã£o Ã© chamada</span>

<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="c1">#declara-se as coordenadas do ponto</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P01&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="c1">#seja qualquer ponto de 3 coordenadas dentro do domÃ­nio ou nÃ£o</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P20&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P21&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
</pre></div>
</div>
<p>O dicionÃ¡rio <code class="xref py py-obj docutils literal notranslate"><span class="pre">point_storage</span></code> faz parte da mecÃ¢nica do cÃ³digo, nÃ£o deve ser alterado. Auxilia na setagem e no armazenamento das informaÃ§Ãµes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.surface_plot">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">surface_plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em>, <em class="sig-param"><span class="n">init_identif</span></em>, <em class="sig-param"><span class="n">final_identif</span></em>, <em class="sig-param"><span class="n">points</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">legend</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.surface_plot" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Visualize all the work done.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Choose which engine will render your solid, <code class="xref py py-obj docutils literal notranslate"><span class="pre">'matplotlib'</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">'mayavi'</span></code>. Mayavi displays better, matplotlib displays more information.</p></li>
<li><p><strong>init_identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Determine o inÃ­cio do intervalo de superfÃ­cies a serem plotadas atravÃ©s da identificaÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code>.</p></li>
<li><p><strong>final_identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Determine o final do intervalo (endpoint nÃ£o incluido) de superfÃ­cies a serem plotadas atravÃ©s da identificaÃ§Ã£o <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code></p></li>
<li><p><strong>points</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Caso queira visualizar os pontos que governam sua superfÃ­cie, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>. VÃ¡lido apenas para <code class="xref py py-obj docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Caso queira deixar de visualizar o domÃ­nio, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>. VÃ¡lido apenas para <code class="xref py py-obj docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>grids</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Caso queira retirar o grid de background, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>. VÃ¡lido apenas para <code class="xref py py-obj docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>legends</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) â€“ Caso queira retirar as legendas das superfÃ­cies, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>. VÃ¡lido apenas para <code class="xref py py-obj docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional) â€“ Controlador da opacidade da superfÃ­cie em questÃ£o. Pode assumir qualquer valor entre <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code> (transparente) e <code class="xref py py-obj docutils literal notranslate"><span class="pre">1</span></code> (opaco). VÃ¡lido apenas para <code class="xref py py-obj docutils literal notranslate"><span class="pre">engine='matplotlib'</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.translate">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">translate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">quantity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.translate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Caso tenha se precipitado em relaÃ§Ã£o Ã  posiÃ§Ã£o de sua superfÃ­cie, translade os pontos governantes de uma superfÃ­cie de BÃ©zier de forma eficiente
em qualquer direÃ§Ã£o.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) â€“ Defina em qual direÃ§Ã£o a translaÃ§Ã£o serÃ¡ feita. Deve assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z'</span></code>.</p></li>
<li><p><strong>quantity</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) â€“ Assume quantas unidades de comprimento de domÃ­nio o usuÃ¡rio quer translate sua superfÃ­cie.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>DeverÃ¡ ser obrigatoriamente chamada entre a funÃ§Ã£o <a class="reference internal" href="#creating_solid.create_point_matrix" title="creating_solid.create_point_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_point_matrix()</span></code></a> e a funÃ§Ã£o <a class="reference internal" href="#creating_solid.gen_bezier_surface" title="creating_solid.gen_bezier_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezier_surface()</span></code></a>.</p>
</div>
<dl>
<dt>Exemplo:</dt><dd><p>Para â€œempurrarâ€ 1.5 unidades para trÃ¡s e â€œpuxarâ€ 0.5 unidades para o lado:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_point_matrix</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P01&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">point_storage</span><span class="p">[</span><span class="s1">&#39;P11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>

<span class="n">create_point_matrix</span><span class="p">()</span>

<span class="n">translate</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>

<span class="n">translate</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">gen_bezier_surface</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="n">capÃ´</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gallery.html" class="btn btn-neutral float-right" title="Galeria" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="howto.html" class="btn btn-neutral float-left" title="How To" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, AndrÃ© Mombach

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>