

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Funções e Respectivas Instruções &mdash; geo_bezier_3d v.0.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Exemplos" href="exemplos.html" />
    <link rel="prev" title="Abordagem de Bézier (ainda em construção)" href="bezier.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> geo_bezier_3d
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Conteúdos:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="bezier.html">Abordagem de Bézier (ainda em construção)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Funções e Respectivas Instruções</a></li>
<li class="toctree-l1"><a class="reference internal" href="exemplos.html">Exemplos</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">geo_bezier_3d</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Funções e Respectivas Instruções</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/instrucoes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-creating_solid">
<span id="funcoes-e-respectivas-instrucoes"></span><span id="instrucoes"></span><h1>Funções e Respectivas Instruções<a class="headerlink" href="#module-creating_solid" title="Permalink to this headline">¶</a></h1>
<p>O usuário recebe nessa página todas informações dos argumentos de todas as funções presentes no código:</p>
<dl class="py function">
<dt id="creating_solid.berstein">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">berstein</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_p</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.berstein" title="Permalink to this definition">¶</a></dt>
<dd><p>Matemática chave por trás das curvas/superfícies de Bézier, dentro da própria função <a class="reference internal" href="#creating_solid.gen_bezi" title="creating_solid.gen_bezi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Não há necessidade alguma de manipulação por parte do usuário.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.cria_matriz_pontos">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">cria_matriz_pontos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">desvio</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.cria_matriz_pontos" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxílio na hora de setar os pontos necessários para as equações da função <a class="reference internal" href="#creating_solid.gen_bezi" title="creating_solid.gen_bezi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>desvio</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> caso queira que a superfície passe pelos pontos de controle
(pontos intermediários, os que normalmente dão a curvatura suave à superfície). Baseia-se num artifício
matemático que <em>hackeia</em> a Bézier, forçando-a a fazer algo que normalmente não faria.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">desvio=True</span></code> <strong>não demonstrará efeito em todos os casos!</strong></p>
<p>O parâmetro pode ficar setado como True sem danificar o código, porém só efetivamente desviará a superfície
caso <code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pontos_u=3</span></code> ao mesmo tempo que <code class="xref py py-obj docutils literal notranslate"><span class="pre">n_pontos_v=2</span></code> ou vice-versa.</p>
<p><strong>O porquê da restrição:</strong></p>
<p>Como pode-se imaginar, não há necessidade de desviar a superfície para passar em pontos intermediários caso existam apenas 2
pontos na direção <code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code> pois não há pontos intermediários. Também, caso a superfície tenha 3 pontos em cada direção
<code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code> ou mais, torna-se <em>matematicamente complicado</em> descrever o desvio.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_bezi">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_bezi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">nome</span></em>, <em class="sig-param"><span class="n">show_equation</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_bezi" title="Permalink to this definition">¶</a></dt>
<dd><p>As equações de Bézier são governadas pelos parâmetros <code class="xref py py-obj docutils literal notranslate"><span class="pre">u</span></code> e <code class="xref py py-obj docutils literal notranslate"><span class="pre">v</span></code> e fornecem leis para curvas/superfícies.</p>
<p>São definidas por pontos arbitrados pelo usuário, tendo um mínimo de 2 em cada direção <code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code> e sem algum máximo pré-determinado.</p>
<p>Os pontos iniciais e finais determinam onde a curva começa e termina, obviamente. <em>São os únicos pontos por onde a Bézier (naturalmente) passará com certeza</em>.
Os pontos intermediários estão encarregados de fornecer à Bézier uma curvatura suave, sem canto vivo/descontinuidade,
portanto a curva/superfície nunca <em>encosta</em> neles.</p>
<p>Como o grau das equações é definido por <code class="xref py py-obj docutils literal notranslate"><span class="pre">número</span> <span class="pre">de</span> <span class="pre">pontos</span> <span class="pre">definidos</span> <span class="pre">pelo</span> <span class="pre">usuário</span> <span class="pre">-</span> <span class="pre">1</span></code>, recomenda-se usar no máximo 3 pontos em cada direção,
para que assim os cálculos se tornem baratos e viáveis. <strong>Caso um objeto seja extremamente complexo, recomenda-se dividí-lo em várias superfícies de grau 2.</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie a <em>identificação</em> da sua superfície com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'n'</span></code>, onde <code class="xref py py-obj docutils literal notranslate"><span class="pre">n=0,1,2,3...</span></code> (começar em ‘0’ e somar ‘1’ a cada nova superfície).</p></li>
<li><p><strong>nome</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Crie um nome para a superfície. Não há regras.</p></li>
<li><p><strong>show_equations</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code> caso queira visualizar as equações governantes da superfície em questão.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">identif()</span></code> <strong>necessita atenção especial</strong>: o usuário voltará a chamar o parâmetro por diversas vezes ao decorrer do código.</p>
</div>
<p>É importante frisar que, caso construída uma superfície muito complexa (com variações não lineares entre os pontos em mais de 2 direções <code class="xref py py-obj docutils literal notranslate"><span class="pre">xyz</span></code>, uma
superfície muito torcida), a convergência das equações não é garantida - por enquanto.</p>
<a class="reference internal image-reference" href="_images/ex_supcomplexa.png"><img alt="_images/ex_supcomplexa.png" class="align-right" src="_images/ex_supcomplexa.png" style="width: 279.2px; height: 266.40000000000003px;" /></a>
<p>A superfície ao lado possui seguintes equações:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(𝑢,𝑣)=4.0𝑢²−2.0𝑢+𝑣²(3.0𝑢2−6.0𝑢+3.0)+𝑣(−6.0𝑢²+12.0𝑢−6.0)+3.0
y(𝑢,𝑣)=2.0𝑢²+𝑣²(2.0𝑢2+1.0)+𝑣(4.0−4.0𝑢²)
z(𝑢,𝑣)=−3.0𝑢²+4.0𝑢+𝑣²(−11.0𝑢²+14.0𝑢−7.0)+𝑣(18.0𝑢²−20.0𝑢+10.0)
</pre></div>
</div>
<p>Evidentemente, são equações longas, não lineares e dependentes de mais de uma variável. O solver não se dá muito bem com isso. Maiores dúvida sobre
convergência consultar a função <code class="xref py py-obj docutils literal notranslate"><span class="pre">previa_interseccao()</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_bezi_cylinder">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_bezi_cylinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bases_plane</span></em>, <em class="sig-param"><span class="n">radius</span></em>, <em class="sig-param"><span class="n">center_1</span></em>, <em class="sig-param"><span class="n">center_2</span></em>, <em class="sig-param"><span class="n">init_height</span></em>, <em class="sig-param"><span class="n">final_height</span></em>, <em class="sig-param"><span class="n">identif_inicial</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_bezi_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Uma função derivada de <a class="reference internal" href="#creating_solid.gen_bezi" title="creating_solid.gen_bezi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi()</span></code></a> que facilita a criação de cilíndros. De saída são geradas
4 Béziers diferentes que juntas formam um cilíndro. Caso esta função seja chamada, no momento de solução
da Epsi será necessário usar a função <a class="reference internal" href="#creating_solid.gen_epsi_cylinder" title="creating_solid.gen_epsi_cylinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi_cylinder()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bases_plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina o plano paralelo à base. Pode assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xy','xz','zy'</span></code>.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Defina o raio do cilíndro.</p></li>
<li><p><strong>center_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coordenada do eixo correspondente à primeira letra do <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code>.</p></li>
<li><p><strong>center_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coordenada do eixo correspondente à segunda letra do <code class="xref py py-obj docutils literal notranslate"><span class="pre">bases_plane</span></code>.</p></li>
<li><p><strong>init_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Altura da base inferior do cilíndro.</p></li>
<li><p><strong>final_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Altura da base superior do cilíndro.</p></li>
<li><p><strong>identif_inicial</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – O mesmo <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> do resto do código. O usuário deverá criar apenas a identificação da primeira
das quatro Béziers geradas na função. Todas as outras identificações são definidas automaticamente.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Exemplo:</dt><dd><p>Para criar um cilíndro de raio 1 e altura 2 no plano <code class="xref py py-obj docutils literal notranslate"><span class="pre">xz</span></code> caso alguma superfície já tenha sido criada e
identificada com <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif='0'</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen_bezi_cylinder</span><span class="p">(</span><span class="n">bases_plane</span><span class="o">=</span><span class="s1">&#39;xz&#39;</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">center_1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">center_2</span><span class="o">=</span><span class="mi">3</span>
                  <span class="n">init_height</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">final_height</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                  <span class="n">identif_inicial</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Como já descrito, são geradas 4 Béziers nesta função. Portanto, caso haja alguma geração de Bézier depois dessa em questão,
o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> deverá ser igual ao desta função somadas mais 4 unidades. No exemplo descrito logo acima, o próximo
<code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code>, quaisquer que seja, deveria ser <code class="xref py py-obj docutils literal notranslate"><span class="pre">'5'</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tipo</span></em>, <em class="sig-param"><span class="n">plano</span></em>, <em class="sig-param"><span class="n">identif</span></em>, <em class="sig-param"><span class="n">simetria</span><span class="o">=</span><span class="default_value">'global'</span></em>, <em class="sig-param"><span class="n">raf0</span><span class="o">=</span><span class="default_value">'normal'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Nesta função, usamos as equações geradas pelos pontos fornecidos pelo usuário para setar os limites de onde é sólido (na Epsi, <code class="xref py py-obj docutils literal notranslate"><span class="pre">1</span></code>) e onde
não é sólido (na Epsi, <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code>). Vamos setar o que é considerado entrada e saída, ou ambos ao mesmo tempo, <strong>para todas as superfícies criadas</strong>.
Vamos, também, tornar mais barata o cálculo de nossa Epsi com simetrias. Vamos definir qual o melhor plano para calcular os limites.</p>
<p><strong>Preste atenção. Se algo pode dar errado, é aqui.</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tipo</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – <p>Defina se a superfície em questão é considerada uma entrada, uma saída ou ambos em relação ao sólido.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tipo</p></th>
<th class="head"><p>Sete  <code class="xref py py-obj docutils literal notranslate"><span class="pre">tipo</span></code> como</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Entrada Pura</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entrada+saída</span> <span class="pre">e/ou</span> <span class="pre">entrada'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Saída Pura</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entrada+saída</span> <span class="pre">e/ou</span> <span class="pre">saída'</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Entrada/Saída Pura</p></td>
<td><p>Tanto faz</p></td>
</tr>
<tr class="row-odd"><td><p>Entrada/Saída + Entrada</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entrada+saída</span> <span class="pre">e/ou</span> <span class="pre">entrada'</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Entrada/Saída + Saída</p></td>
<td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">'entrada+saída</span> <span class="pre">e/ou</span> <span class="pre">saída'</span></code></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>plano</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Escolha o melhor plano para resolver sua superfície. Caso o plano xy seja o melhor, setar <code class="xref py py-obj docutils literal notranslate"><span class="pre">plano='xy'</span></code>. Pode assumir apenas <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xz','xy','zy'</span></code>.</p></li>
<li><p><strong>identif</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Repita o argumento <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> da superfície em questão.</p></li>
<li><p><strong>simetria</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Defina alguma simetria de auxílio para barateamento do cálculo da Epsi. Pode assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'simetria_x','simetria_y',simetria_z'</span></code>.
Caso utilize este termo, projete apenas metade das superfícies caso elas cruzem o eixo de simetria. Caso contrário, o método não resulta em ganhos significativos.</p></li>
<li><p><strong>raf0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Não há necessidade alguma de manipulação por parte do usuário.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt><strong>Exemplo:</strong></dt><dd><div class="figure align-center">
<a class="reference internal image-reference" href="_images/ex_entradasaidasaida.png"><img alt="_images/ex_entradasaidasaida.png" src="_images/ex_entradasaidasaida.png" style="width: 491.4px; height: 489.99999999999994px;" /></a>
</div>
<p>Podemos notar 2 supefícies na figura, uma verde (<code class="xref py py-obj docutils literal notranslate"><span class="pre">identif='0'</span></code>) e outra roxa (<code class="xref py py-obj docutils literal notranslate"><span class="pre">identif='1'</span></code>).
De acordo com esta situação, a invocação da função <a class="reference internal" href="#creating_solid.gen_epsi" title="creating_solid.gen_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi()</span></code></a> pode se dar na seguinte forma:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen_epsi</span><span class="p">(</span><span class="s1">&#39;entrada+saída e/ou entrada&#39;</span><span class="p">,</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">gen_epsi</span><span class="p">(</span><span class="s1">&#39;entrada+saída e/ou saída&#39;</span><span class="p">,</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Podemos notar também um ponto que é o início de um vetor perpendicular ao plano ‘zy’. Este vetor é a representação do que define o <code class="xref py py-obj docutils literal notranslate"><span class="pre">tipo</span></code> de cada superfície.
Toda vez que o vetor encontrar alguma superfícies, será definido um limite para a criação da Epsi.
Devemos imaginar que para cada combinação de coordenada ‘z’ e ‘y’ (espaçamento definido por dz e dy) um vetor desses é originado. Portanto:</p>
<blockquote>
<div><p>1. O sólido verde é considerado <em>Entrada Pura</em> pois, no instante em que é interceptado pelos vetores,
<strong>entra-se no sólido</strong>.</p>
<p>2. O sólido roxo deve ser dividido em 2 partes e é considerado <em>Entrada/Saída + Saída</em>. A primeira parte é a superior, logo acima da superfície verde.
Toda esta parte será interceptada pelos vetores duas vezes e <strong>por isso é considerada entrada/saída</strong>. A segunda parte é a inferior, que ‘compartilha’
altura com a superfície verde. Esta parte será interceptada pelos vetores apenas uma vez e em todas elas o sólido já terá acabado, por isso é considerada
também como <strong>saída</strong>.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Caso construída uma superfície que possua segmentos com possíveis entradas/saídas simultâneas (superfície roxa), certificar que a superfície seja construída
no sentido positivo: os pontos iniciais devem ser mais próximos da origem do que os pontos finais, independente do plano.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Caso a superfície identificada com <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> seja <em>entrada</em>, a partir do momento em que a Epsi encontrar a superfície até o fim da
Epsi será setado como 1. Caso seja <em>saída</em>,
a partir do momento em que a Epsi encontrar a superfície até o fim da Epsi será setado como 0.</p>
<p><em>É necessário perceber que a ordem com que essa
função é chamada tem muita importância:</em> caso o usuário chame primeiro as saídas, o código vai entender que a partir do encontro da superfície
é necessário marcar como 0 algo que já está setado como 0 (a matriz Epsi é setada inicialmente apemas com 0, com dimensões nx, ny e nz). Seguindo a lógica,
o usuário agora então chamaria as entradas. A partir do encontro da superfície, tudo será setado com 1 até o fim da matriz e assim ficará definido.
Ou seja, o sólido <em>não foi representado corretamente.</em></p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Explicando ‘plano’ mais uma vez:</strong></p>
<p>Para cada combinação de coordenada (xy, xz ou zy), imagine um vetor saíndo de cada nó existente.
Como por exemplo, falaremos do plano xy. De cada posição x e de cada posição y possível, sairá um vetor em direção à z.
Toda vez que esse vetor cruzar uma superfície, será contabilizado um limite para a Epsi. O usuário já determinou que
tipo de limite será no argumento anterior.
<em>Logo, é de extrema importância que o usuário escolha o plano certo para resolver o seu sólido.</em>
Imagine outro exemplo, onde o usuário construiu um quadrado no plano xy (ou seja, paralelo ao plano xy), com alguma altura constante qualquer.
Esse quadrado não possui dimensão alguma para qualquer plano a não ser o plano xy.
Em outras palavras, o plano zy e o plano zx nunca cruzarão este quadrado, logo a Epsi não será construída corretamente pois não haverá limite algum para isso.
E isso é perfeitamente demonstrado pela a função <code class="xref py py-obj docutils literal notranslate"><span class="pre">previa_interseccao()</span></code>. Inclusive, o retorno desta função explicita onde há interceptação dos vetores com a superfície,
tornando mais clara a escolha deste argumento.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_epsi_cylinder">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_epsi_cylinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bases_plane</span></em>, <em class="sig-param"><span class="n">tipo</span></em>, <em class="sig-param"><span class="n">plano</span></em>, <em class="sig-param"><span class="n">identif_inicial</span></em>, <em class="sig-param"><span class="n">simetria</span><span class="o">=</span><span class="default_value">'global'</span></em>, <em class="sig-param"><span class="n">raf0</span><span class="o">=</span><span class="default_value">'normal'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_epsi_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Uma função derivada de <a class="reference internal" href="#creating_solid.gen_epsi" title="creating_solid.gen_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi()</span></code></a> que facilita a geração da Epsi de cilíndros criados com a função
<a class="reference internal" href="#creating_solid.gen_bezi_cylinder" title="creating_solid.gen_bezi_cylinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi_cylinder()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bases_plane</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Pode assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xy','xz','zy'</span></code>. Deverá ser igual ao definido para o cilíndro em questão na função <a class="reference internal" href="#creating_solid.gen_bezi_cylinder" title="creating_solid.gen_bezi_cylinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi_cylinder()</span></code></a>.</p></li>
<li><p><strong>tipo</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina se a superfície em questão é considerada um <code class="xref py py-obj docutils literal notranslate"><span class="pre">'contorno'</span></code> (imagine posicionar um cilíndro dentro de
um cubo e subtraí-lo, como se fosse uma tubulação) ou um <code class="xref py py-obj docutils literal notranslate"><span class="pre">'sólido'</span></code> (ideal para pneus, rodas, etc). A variável só pode assumir os dois termos destacados.</p></li>
<li><p><strong>plano</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Escolha o melhor plano para resolver sua superfície. Pode assumir apenas <code class="xref py py-obj docutils literal notranslate"><span class="pre">'xz','xy','zy'</span></code>. Mais informações em <a class="reference internal" href="#creating_solid.gen_epsi" title="creating_solid.gen_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi()</span></code></a>.</p></li>
<li><p><strong>identif_inicial</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – O mesmo <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code> setado para o cilíndro em questão na função <a class="reference internal" href="#creating_solid.gen_bezi_cylinder" title="creating_solid.gen_bezi_cylinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi_cylinder()</span></code></a>.</p></li>
<li><p><strong>simetria</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Pode assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'simetria_x','simetria_y',simetria_z'</span></code>. Mais informações em <a class="reference internal" href="#creating_solid.gen_epsi" title="creating_solid.gen_epsi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_epsi()</span></code></a>.</p></li>
<li><p><strong>raf0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Não há necessidade alguma de manipulação por parte do usuário.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_output">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">names</span></em>, <em class="sig-param"><span class="n">raf2</span><span class="o">=</span><span class="default_value">'normal'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Geraração do arquivo que torna possível a visualização no ParaView da Epsi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Entre com o nome que será dado aos arquivos gerado pelo programa.</p></li>
<li><p><strong>raf2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Não há necessidade alguma de manipulação por parte do usuário.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.gen_raf_epsi">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">gen_raf_epsi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">nraf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.gen_raf_epsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Geração da Epsi refinada, importante arquivo para o <code class="xref py py-obj docutils literal notranslate"><span class="pre">Incompact3d</span></code>. O objetivo é obter maior precisão em cada dimensão por vez.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nraf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Entre com o número de vezes que gostaria de multiplicar os nós (refinar a malha).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.plot_epsi">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">plot_epsi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direcao</span></em>, <em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">integral</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">raf1</span><span class="o">=</span><span class="default_value">'normal'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.plot_epsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Confira se os limites estão corretos, camada por camada ou por amostragem, em qualquer direção.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direcao</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Poderá assumir os seguintes valores: <code class="xref py py-obj docutils literal notranslate"><span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z'</span></code>.</p></li>
<li><p><strong>grid</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso houver número demasiado de nós (&gt;250), setar como <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code> auxiliará na visualização.</p></li>
<li><p><strong>integral</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Se o usuário quiser conferir meticulosamente todas as camadas, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>raf1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional) – Se o usuário quiser conferir alguma Epsi Refinada, setar com <code class="xref py py-obj docutils literal notranslate"><span class="pre">'x','y','z'</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.plota_superficie">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">plota_superficie</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif_inicial</span></em>, <em class="sig-param"><span class="n">identif_final</span></em>, <em class="sig-param"><span class="n">pontos</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.3</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.plota_superficie" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif_inicial</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Determine o início do intervalo de superfícies a serem plotadas através da identificação <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code>.</p></li>
<li><p><strong>identif_final</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Determine o final do intervalo (endpoint não incluido) de superfícies a serem plotadas através da identificação <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code></p></li>
<li><p><strong>pontos</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Bool</span></code>, optional) – Caso queira visualizar os pontos que governam sua superfície, sete como <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional) – Controlador da opacidade da superfície em questão. Pode assumir qualquer valor entre <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code> (transparente) e <code class="xref py py-obj docutils literal notranslate"><span class="pre">1</span></code> (opaco).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.prepara_matriz_pontos">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">prepara_matriz_pontos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pontos_u</span></em>, <em class="sig-param"><span class="n">pontos_v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.prepara_matriz_pontos" title="Permalink to this definition">¶</a></dt>
<dd><p>Importante função em que o usuário determinará o número de pontos em cada direção <code class="xref py py-obj docutils literal notranslate"><span class="pre">[u,v]</span></code>.</p>
<p>Caso fique em dúvida da nomenclatura de quais pontos serão necessários setar, execute uma célula (após executar a função em pauta) com <code class="xref py py-obj docutils literal notranslate"><span class="pre">print(armz_pt)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#exemplo de como tirar a dúvida dos pontos que devem receber algum input</span>
<span class="n">prepara_matriz_pontos</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">armz_pt</span><span class="p">)</span>
</pre></div>
</div>
<p>Basicamente, os pontos a serem determinados possuem 2 sub-índices: <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code> e <code class="xref py py-obj docutils literal notranslate"><span class="pre">j</span></code> → <code class="xref py py-obj docutils literal notranslate"><span class="pre">Pij</span></code>.</p>
<p>Os sub-índices começarão em <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code> e irão até <code class="xref py py-obj docutils literal notranslate"><span class="pre">i-1</span></code> e/ou <code class="xref py py-obj docutils literal notranslate"><span class="pre">j-1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pontos_u</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Determine o número de pontos que a direção <code class="xref py py-obj docutils literal notranslate"><span class="pre">u</span></code> terá.</p></li>
<li><p><strong>pontos_v</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Determine o número de pontos que a direção <code class="xref py py-obj docutils literal notranslate"><span class="pre">v</span></code> terá.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Exemplo:</dt><dd><p>Será explicitado quais pontos deverão ser setados de acordo com as entradas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prepara_matriz_pontos</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#função é chamada</span>

<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="c1">#declara-se as informações do ponto</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P01&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="c1">#qualquer ponto de 3 coordenadas dentro do domínio</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P20&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P21&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
</pre></div>
</div>
<p>Note que o primeiro subíndice, <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>, começa em <code class="xref py py-obj docutils literal notranslate"><span class="pre">0</span></code> e termina em <code class="xref py py-obj docutils literal notranslate"><span class="pre">2</span></code>, que é o correspondente a <code class="xref py py-obj docutils literal notranslate"><span class="pre">pontos_u=3-pontos_v=1</span></code>.</p>
<p>O dicionário <code class="xref py py-obj docutils literal notranslate"><span class="pre">armz_pt</span></code> faz parte da mecânica do código, não deve ser alterado. Auxilia na setagem e no armazenamento das informações.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.previa_interseccao">
<span id="creating_solid.previa_intersecçao"></span><code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">previa_intersecçao</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">identif_inicial</span></em>, <em class="sig-param"><span class="n">identif_final</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.previa_interseccao" title="Permalink to this definition">¶</a></dt>
<dd><p>Uma <em>mini simulação de Epsi</em>. Para poucos nós em cada direção será checado se os limites são coerentes ou não,
ou seja, <strong>se as funções convergiram para o determinado espaçamento de nós ou não</strong>. Cada ponto no gráfico significa uma intersecção entre o vetor e a superfície.
Se todos forem razoáveis, a superfície será bem entendida pelo solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>identif_inicial</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Determine o início do intervalo de superfícies a serem calculadas através da identificação <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code>.</p></li>
<li><p><strong>identif_final</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Determine o final do intervalo (endpoint não incluido) de superfícies a serem calcuadas através da identificação <code class="xref py py-obj docutils literal notranslate"><span class="pre">identif</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="creating_solid.transladar">
<code class="sig-prename descclassname">creating_solid.</code><code class="sig-name descname">transladar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direcao</span></em>, <em class="sig-param"><span class="n">quantidade</span></em><span class="sig-paren">)</span><a class="headerlink" href="#creating_solid.transladar" title="Permalink to this definition">¶</a></dt>
<dd><p>Caso tenha se precipitado em relação à posição de sua superfície, translade seus pontos de forma eficiente
em qualquer direção.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direcao</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Defina em qual direção a translação será feita. Deve assumir <code class="xref py py-obj docutils literal notranslate"><span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z'</span></code>.</p></li>
<li><p><strong>quantidade</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Assume quantas unidades de comprimento de domínio o usuário quer transladar sua superfície.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Deverá ser obrigatoriamente chamada entre a função <a class="reference internal" href="#creating_solid.cria_matriz_pontos" title="creating_solid.cria_matriz_pontos"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cria_matriz_pontos()</span></code></a> e a função <a class="reference internal" href="#creating_solid.gen_bezi" title="creating_solid.gen_bezi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_bezi()</span></code></a>.</p>
</div>
<p>Exemplo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prepara_matriz_pontos</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P01&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="n">armz_pt</span><span class="p">[</span><span class="s1">&#39;P11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>

<span class="n">cria_matriz_pontos</span><span class="p">()</span>

<span class="n">transladar</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>

<span class="n">transladar</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">gen_bezi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="n">capô</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="exemplos.html" class="btn btn-neutral float-right" title="Exemplos" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bezier.html" class="btn btn-neutral float-left" title="Abordagem de Bézier (ainda em construção)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, André Mombach

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>